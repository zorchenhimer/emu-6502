ca65 V2.18 - Git 857a566a
Main file   : 6502_functional_test.ca65
Current file: 6502_functional_test.ca65

000000r 1               ;
000000r 1               ; This program is distributed in the hope that it will be useful,
000000r 1               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 1               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 1               ; GNU General Public License for more details.
000000r 1               ;
000000r 1               ; You should have received a copy of the GNU General Public License
000000r 1               ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
000000r 1               
000000r 1               
000000r 1               ; This program is designed to test all opcodes of a 6502 emulator using all
000000r 1               ; addressing modes with focus on propper setting of the processor status
000000r 1               ; register bits.
000000r 1               ;
000000r 1               ; version 01-aug-2019
000000r 1               ; contact info at http://2m5.de or email K@2m5.de
000000r 1               ;
000000r 1               ; assembled with CA65, linked with LD65 (cc65.github.io):
000000r 1               ;  ca65 -l 6502_functional_test.lst 6502_functional_test.ca65
000000r 1               ;  ld65 6502_functional_test.o -o 6502_functional_test.bin \
000000r 1               ;   -m 6502_functional_test.map -C example.cfg
000000r 1               ; example linker config (example.cfg):
000000r 1               ;  MEMORY {
000000r 1               ;  RAM: start = $0000, size=$8000, type = rw, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM: start = $8000, size=$7FFA, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM_VECTORS: start = $FFFA, size=6, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  }
000000r 1               ;  SEGMENTS {
000000r 1               ;  ZEROPAGE: load=RAM, type=rw;
000000r 1               ;  DATA: load=RAM, type=rw, offset=$0200;
000000r 1               ;  CODE: load=RAM, type=rw, offset=$0400;
000000r 1               ;  VECTORS: load=ROM_VECTORS, type=ro;
000000r 1               ;  }
000000r 1               ;
000000r 1               ; No IO - should be run from a monitor with access to registers.
000000r 1               ; To run load intel hex image with a load command, than alter PC to 400 hex
000000r 1               ; (code_segment) and enter a go command.
000000r 1               ; Loop on program counter determines error or successful completion of test.
000000r 1               ; Check listing for relevant traps (jump/branch *).
000000r 1               ; Please note that in early tests some instructions will have to be used before
000000r 1               ; they are actually tested!
000000r 1               ;
000000r 1               ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
000000r 1               ; Tests documented behavior of the original NMOS 6502 only! No unofficial
000000r 1               ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
000000r 1               ; not be tested. Decimal ops will only be tested with valid BCD operands and
000000r 1               ; N V Z flags will be ignored.
000000r 1               ;
000000r 1               ; Debugging hints:
000000r 1               ;     Most of the code is written sequentially. if you hit a trap, check the
000000r 1               ;   immediately preceeding code for the instruction to be tested. Results are
000000r 1               ;   tested first, flags are checked second by pushing them onto the stack and
000000r 1               ;   pulling them to the accumulator after the result was checked. The "real"
000000r 1               ;   flags are no longer valid for the tested instruction at this time!
000000r 1               ;     If the tested instruction was indexed, the relevant index (X or Y) must
000000r 1               ;   also be checked. Opposed to the flags, X and Y registers are still valid.
000000r 1               ;
000000r 1               ; versions:
000000r 1               ;   28-jul-2012  1st version distributed for testing
000000r 1               ;   29-jul-2012  fixed references to location 0, now #0
000000r 1               ;                added license - GPLv3
000000r 1               ;   30-jul-2012  added configuration options
000000r 1               ;   01-aug-2012  added trap macro to allow user to change error handling
000000r 1               ;   01-dec-2012  fixed trap in branch field must be a branch
000000r 1               ;   02-mar-2013  fixed PLA flags not tested
000000r 1               ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
000000r 1               ;                added test sequence check to detect if tests jump their fence
000000r 1               ;   23-jul-2013  added RAM integrity check option
000000r 1               ;   16-aug-2013  added error report to standard output option
000000r 1               ;   13-dec-2014  added binary/decimal opcode table switch test
000000r 1               ;   14-dec-2014  improved relative address test
000000r 1               ;   23-aug-2015  added option to disable self modifying tests
000000r 1               ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
000000r 1               ;                added small branch offset pretest
000000r 1               ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
000000r 1               ;   04-dec-2017  fixed BRK only tested with interrupts enabled
000000r 1               ;                added option to skip the remainder of a failing test
000000r 1               ;                in report.i65
000000r 1               
000000r 1               
000000r 1               ; C O N F I G U R A T I O N
000000r 1               
000000r 1               ;ROM_vectors writable (0=no, 1=yes)
000000r 1               ;if ROM vectors can not be used interrupts will not be trapped
000000r 1               ;as a consequence BRK can not be tested but will be emulated to test RTI
000000r 1               ROM_vectors = 1
000000r 1               
000000r 1               ;load_data_direct (0=move from code segment, 1=load directly)
000000r 1               ;loading directly is preferred but may not be supported by your platform
000000r 1               ;0 produces only consecutive object code, 1 is not suitable for a binary image
000000r 1               load_data_direct = 1
000000r 1               
000000r 1               ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
000000r 1               ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
000000r 1               ;tested if you allow changing the interrupt status (I_flag = 3)
000000r 1               I_flag = 3
000000r 1               
000000r 1               ;configure memory - try to stay away from memory used by the system
000000r 1               ;zero_page memory start address, $50 (80) consecutive Bytes required
000000r 1               ;                                add 2 if I_flag = 2
000000r 1               zero_page = $a
000000r 1               
000000r 1               ;data_segment memory start address, $6A (106) consecutive Bytes required
000000r 1               ; check that this matches the linker configuration file
000000r 1               data_segment = $200
000000r 1                   .if (data_segment & $ff) <> 0
000000r 1                       .error "low byte of data_segment MUST be $00 !!"
000000r 1                   .endif
000000r 1               
000000r 1               ;code_segment memory start address, 13kB of consecutive space required
000000r 1               ;                                   add 2.5 kB if I_flag = 2
000000r 1               ; check that this matches the linker configuration file
000000r 1               code_segment = $400
000000r 1               
000000r 1               ;self modifying code may be disabled to allow running in ROM
000000r 1               ;0=part of the code is self modifying and must reside in RAM
000000r 1               ;1=tests disabled: branch range
000000r 1               disable_selfmod = 0
000000r 1               
000000r 1               ;report errors through I/O channel (0=use standard self trap loops, 1=include
000000r 1               ;report.i65 as I/O channel, add 3.5 kB)
000000r 1               report = 0
000000r 1               
000000r 1               ;RAM integrity test option. Checks for undesired RAM writes.
000000r 1               ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
000000r 1               ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
000000r 1               ram_top = 0
000000r 1               
000000r 1               ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
000000r 1               ;2=disable including decimal flag in processor status
000000r 1               disable_decimal = 1
000000r 1               
000000r 1               ;macros for error & success traps to allow user modification
000000r 1               ;example:
000000r 1               ;        .macro  trap
000000r 1               ;        jsr my_error_handler
000000r 1               ;        .endmacro
000000r 1               ;        .macro  trap_eq
000000r 1               ;        bne :+
000000r 1               ;        trap           ;failed equal (zero)
000000r 1               ;:
000000r 1               ;        .endmacro
000000r 1               ;
000000r 1               ; my_error_handler should pop the calling address from the stack and report it.
000000r 1               ; putting larger portions of code (more than 3 bytes) inside the trap macro
000000r 1               ; may lead to branch range problems for some tests.
000000r 1                   .if report = 0
000000r 1                       .macro  trap
000000r 1                       jmp *           ;failed anyway
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       beq *           ;failed equal (zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       bne *           ;failed not equal (non zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcs *           ;failed carry set
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcc *           ;failed carry clear
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bmi *           ;failed minus (bit 7 set)
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bpl *           ;failed plus (bit 7 clear)
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvs *           ;failed overflow set
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvc *           ;failed overflow clear
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jmp *           ;test passed, no errors
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1                   .if report = 1
000000r 1                       .macro  trap
000000r 1                       jsr report_error
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       bne :+
000000r 1                       trap           ;failed equal (zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       beq :+
000000r 1                       trap            ;failed not equal (non zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcc :+
000000r 1                       trap            ;failed carry set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcs :+
000000r 1                       trap            ;failed carry clear
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bpl :+
000000r 1                       trap            ;failed minus (bit 7 set)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bmi :+
000000r 1                       trap            ;failed plus (bit 7 clear)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvc :+
000000r 1                       trap            ;failed overflow set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvs :+
000000r 1                       trap            ;failed overflow clear
000000r 1               :
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jsr report_success
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1               
000000r 1                   .define equ =
000000r 1               
000000r 1                   .define dbg .byte $1A
000000r 1               
000000r 1               carry   equ %00000001   ;flag bits in status
000000r 1               zero    equ %00000010
000000r 1               intdis  equ %00000100
000000r 1               decmode equ %00001000
000000r 1               break   equ %00010000
000000r 1               reserv  equ %00100000
000000r 1               overfl  equ %01000000
000000r 1               minus   equ %10000000
000000r 1               
000000r 1               fc      equ carry
000000r 1               fz      equ zero
000000r 1               fzc     equ carry+zero
000000r 1               fv      equ overfl
000000r 1               fvz     equ overfl+zero
000000r 1               fn      equ minus
000000r 1               fnc     equ minus+carry
000000r 1               fnz     equ minus+zero
000000r 1               fnzc    equ minus+zero+carry
000000r 1               fnv     equ minus+overfl
000000r 1               
000000r 1               fao     equ break+reserv    ;bits always on after PHP, BRK
000000r 1               fai     equ fao+intdis      ;+ forced interrupt disable
000000r 1               faod    equ fao+decmode     ;+ ignore decimal
000000r 1               faid    equ fai+decmode     ;+ ignore decimal
000000r 1               m8      equ $ff             ;8 bit mask
000000r 1               m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
000000r 1               
000000r 1               ;macros to allow masking of status bits.
000000r 1               ;masking test of decimal bit
000000r 1               ;masking of interrupt enable/disable on load and compare
000000r 1               ;masking of always on bits after PHP or BRK (unused & break) on compare
000000r 1                   .if disable_decimal < 2
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i          ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8i   ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fai)&m8    ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1|fai)       ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           cmp #(p1|fao)&m8i   ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8    ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #p1|fao         ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .else
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i         ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faid)&m8   ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1|faid)      ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8   ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #p1|faod        ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .endif
000000r 1               
000000r 1               ;macros to set (register|memory|zeropage) & status
000000r 1                           .macro      set_stat    p1          ;setting flags in the processor status register
000000r 1                           load_flag p1
000000r 1                           pha         ;use stack to load status
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_a       p1,p2       ;precharging accu & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda #p1     ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_x       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldx #p1     ;precharge index x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_y       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldy #p1     ;precharge index y
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ax      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ay      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,y    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_z       p1,p2       ;precharging indexed zp & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to zeropage
000000r 1                           sta zpt
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_zx      p1,p2       ;precharging zp,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed zeropage
000000r 1                           sta zpt,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_abs     p1,p2       ;precharging indexed memory & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to memory
000000r 1                           sta abst
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_absx    p1,p2       ;precharging abs,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed memory
000000r 1                           sta abst,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1               ;macros to test (register|memory|zeropage) & status & (mask)
000000r 1                           .macro      tst_stat    p1          ;testing flags in the processor status register
000000r 1                           php         ;save status
000000r 1                           pla         ;use stack to retrieve status
000000r 1                           pha
000000r 1                           cmp_flag p1
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_a       p1,p2        ;testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_x       p1,p2       ;testing result in x index & flags
000000r 1                           php         ;save flags
000000r 1                           cpx #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_y       p1,p2       ;testing result in y index & flags
000000r 1                           php         ;save flags
000000r 1                           cpy #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ax      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne     ;
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ay      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,y    ;test result
000000r 1                           trap_ne     ;
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,y    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_z       p1,p2,p3    ;indexed testing result in zp & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_zx      p1,p2,p3    ;testing result in zp,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_abs     p1,p2,p3    ;indexed testing result in memory & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_absx    p1,p2,p3    ;testing result in abs,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1               ; RAM integrity test
000000r 1               ;   verifies that none of the previous tests has altered RAM outside of the
000000r 1               ;   designated write areas.
000000r 1               ;   uses zpt word as indirect pointer, zpt+2 word as checksum
000000r 1                   .macro check_ram
000000r 1                       .if ram_top > -1
000000r 1                           dbg
000000r 1                           cld
000000r 1                           lda #0
000000r 1                           sta zpt         ;set low byte of indirect pointer
000000r 1                           sta zpt+3       ;checksum high byte
000000r 1                         .if disable_selfmod = 0
000000r 1                           sta range_adr   ;reset self modifying code
000000r 1                         .endif
000000r 1                           clc
000000r 1                           ldx #zp_bss-zero_page ;zeropage - write test area
000000r 1               : ;css3
000000r 1                           adc zero_page,x
000000r 1                           bcc :+ ;css2
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               : ;css2
000000r 1                           inx
000000r 1                           bne :-- ;css3
000000r 1                           ldx #.hibyte(abs1)   ;set high byte of indirect pointer
000000r 1                           stx zpt+1
000000r 1                           ldy #.lobyte(abs1)   ;data after write & execute test area
000000r 1               : ;css5
000000r 1                           adc (zpt),y
000000r 1                           bcc :+ ;css4
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               : ;css4
000000r 1                           iny
000000r 1                           bne :-- ;css5
000000r 1                           inx             ;advance RAM high address
000000r 1                           stx zpt+1
000000r 1                           cpx #ram_top
000000r 1                           bne :-- ;css5
000000r 1                           sta zpt+2       ;checksum low is
000000r 1                           cmp ram_chksm   ;checksum low expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           lda zpt+3       ;checksum high is
000000r 1                           cmp ram_chksm+1 ;checksum high expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                       .endif
000000r 1                   .endmacro
000000r 1               
000000r 1                           .macro  next_test   ;make sure, tests don't jump the fence
000000r 1                           lda test_case   ;previous test
000000r 1                           cmp #test_num
000000r 1                           trap_ne         ;test is out of sequence
000000r 1               test_num .set test_num + 1
000000r 1                           lda #test_num   ;*** next tests' number
000000r 1                           sta test_case
000000r 1                           check_ram       ;uncomment to find altered RAM after each test
000000r 1                           .endmacro
000000r 1               
000000r 1                       .ZEROPAGE
000000r 1  00 00 00 00  		.res zero_page, 0
000004r 1  00 00 00 00  
000008r 1  00 00        
00000Ar 1                       .org zero_page
00000A  1               
00000A  1               ;break test interrupt save
00000A  1  00           irq_a:  .res    1,0             ;a register
00000B  1  00           irq_x:  .res    1,0             ;x register
00000C  1                   .if I_flag = 2
00000C  1               ;masking for I bit in status
00000C  1               flag_I_on:  .res    1,0         ;or mask to load flags
00000C  1               flag_I_off: .res    1,0         ;and mask to load flags
00000C  1                   .endif
00000C  1               zpt:                        ;5 bytes store/modify test area
00000C  1               ;add/subtract operand generation and result/flag prediction
00000C  1  00           adfc:   .res    1,0             ;carry flag before op
00000D  1  00           ad1:    .res    1,0             ;operand 1 - accumulator
00000E  1  00           ad2:    .res    1,0             ;operand 2 - memory / immediate
00000F  1  00           adrl:   .res    1,0             ;expected result bits 0-7
000010  1  00           adrh:   .res    1,0             ;expected result bit 8 (carry)
000011  1  00           adrf:   .res    1,0             ;expected flags NV0000ZC (only binary mode)
000012  1  00           sb2:    .res    1,0             ;operand 2 complemented for subtract
000013  1               zp_bss:
000013  1  C3 82 41 00  zp1:    .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000017  1  7F           zp7f:   .byte   $7f             ;test pattern for compare
000018  1               ;logical zeropage operands
000018  1  00 1F 71 80  zpOR:   .byte   0,$1f,$71,$80   ;test pattern for OR
00001C  1  0F FF 7F 80  zpAN:   .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000020  1  FF 0F 8F 8F  zpEO:   .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000024  1               ;indirect addressing pointers
000024  1  17 02        ind1:   .word   abs1            ;indirect pointer to pattern in absolute memory
000026  1  18 02                .word   abs1+1
000028  1  19 02                .word   abs1+2
00002A  1  1A 02                .word   abs1+3
00002C  1  1B 02                .word   abs7f
00002E  1  1F 01        inw1:   .word   abs1-$f8        ;indirect pointer for wrap-test pattern
000030  1  03 02        indt:   .word   abst            ;indirect pointer to store area in absolute memory
000032  1  04 02                .word   abst+1
000034  1  05 02                .word   abst+2
000036  1  06 02                .word   abst+3
000038  1  0B 01        inwt:   .word   abst-$f8        ;indirect pointer for wrap-test store
00003A  1  4E 02        indAN:  .word   absAN           ;indirect pointer to AND pattern in absolute memory
00003C  1  4F 02                .word   absAN+1
00003E  1  50 02                .word   absAN+2
000040  1  51 02                .word   absAN+3
000042  1  52 02        indEO:  .word   absEO           ;indirect pointer to EOR pattern in absolute memory
000044  1  53 02                .word   absEO+1
000046  1  54 02                .word   absEO+2
000048  1  55 02                .word   absEO+3
00004A  1  4A 02        indOR:  .word   absOR           ;indirect pointer to OR pattern in absolute memory
00004C  1  4B 02                .word   absOR+1
00004E  1  4C 02                .word   absOR+2
000050  1  4D 02                .word   absOR+3
000052  1               ;add/subtract indirect pointers
000052  1  03 02        adi2:   .word   ada2            ;indirect pointer to operand 2 in absolute memory
000054  1  04 02        sbi2:   .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
000056  1  04 01        adiy2:  .word   ada2-$ff        ;with offset for indirect indexed
000058  1  05 01        sbiy2:  .word   sba2-$ff
00005A  1               zp_bss_end:
00005A  1               
00005A  1                       .DATA
00005A  1                       .org data_segment
000200  1               
000200  1  00           test_case:  .res    1,0         ;current test number
000201  1  00 00        ram_chksm:  .res    2,0         ;checksum for RAM integrity test
000203  1               ;add/subtract operand copy - abs tests write area
000203  1               abst:                       ;5 bytes store/modify test area
000203  1  00           ada2:   .res    1,0             ;operand 2
000204  1  00           sba2:   .res    1,0             ;operand 2 complemented for subtract
000205  1  00 00 00             .res    3,0             ;fill remaining bytes
000208  1               data_bss:
000208  1                   .if load_data_direct = 1
000208  1  29 00        ex_andi:and #0              ;execute immediate opcodes
00020A  1  60                   rts
00020B  1  49 00        ex_eori:eor #0              ;execute immediate opcodes
00020D  1  60                   rts
00020E  1  09 00        ex_orai:ora #0              ;execute immediate opcodes
000210  1  60                   rts
000211  1  69 00        ex_adci:adc #0              ;execute immediate opcodes
000213  1  60                   rts
000214  1  E9 00        ex_sbci:sbc #0              ;execute immediate opcodes
000216  1  60                   rts
000217  1                   .else
000217  1               ex_andi:.res    3
000217  1               ex_eori:.res    3
000217  1               ex_orai:.res    3
000217  1               ex_adci:.res    3
000217  1               ex_sbci:.res    3
000217  1                   .endif
000217  1  C3 82 41 00  abs1:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00021B  1  7F           abs7f:  .byte   $7f             ;test pattern for compare
00021C  1               ;loads
00021C  1  80 80 00 02  fLDx:   .byte   fn,fn,0,fz      ;expected flags for load
000220  1               ;shifts
000220  1               rASL:                       ;expected result ASL & ROL -carry
000220  1  86 04 82 00  rROL:   .byte   $86,$04,$82,0   ; "
000224  1  87 05 83 01  rROLc:  .byte   $87,$05,$83,1   ;expected result ROL +carry
000228  1               rLSR:                       ;expected result LSR & ROR -carry
000228  1  61 41 20 00  rROR:   .byte   $61,$41,$20,0   ; "
00022C  1  E1 C1 A0 80  rRORc:  .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
000230  1               fASL:                       ;expected flags for shifts
000230  1  81 01 80 02  fROL:   .byte   fnc,fc,fn,fz    ;no carry in
000234  1  81 01 80 00  fROLc:  .byte   fnc,fc,fn,0     ;carry in
000238  1               fLSR:
000238  1  01 00 01 02  fROR:   .byte   fc,0,fc,fz      ;no carry in
00023C  1  81 80 81 80  fRORc:  .byte   fnc,fn,fnc,fn   ;carry in
000240  1               ;increments (decrements)
000240  1  7F 80 FF 00  rINC:   .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
000244  1  01           
000245  1  00 80 80 02  fINC:   .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
000249  1  00           
00024A  1               ;logical memory operand
00024A  1  00 1F 71 80  absOR:  .byte   0,$1f,$71,$80   ;test pattern for OR
00024E  1  0F FF 7F 80  absAN:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000252  1  FF 0F 8F 8F  absEO:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000256  1               ;logical accu operand
000256  1  00 F1 1F 00  absORa: .byte   0,$f1,$1f,0     ;test pattern for OR
00025A  1  F0 FF FF FF  absANa: .byte   $f0,$ff,$ff,$ff ;test pattern for AND
00025E  1  FF F0 F0 0F  absEOa: .byte   $ff,$f0,$f0,$0f ;test pattern for EOR
000262  1               ;logical results
000262  1  00 FF 7F 80  absrlo: .byte   0,$ff,$7f,$80
000266  1  02 80 00 80  absflo: .byte   fz,fn,0,fn
00026A  1               data_bss_end:
00026A  1               
00026A  1               
00026A  1                       .CODE
00026A  1                       .org code_segment
000400  1                       .P02            ; disable 65SC02, 65C02 and 65816 instructions
000400  1  1A           start:
000401  1                       dbg
000401  1  D8                   cld
000402  1  A2 FF                ldx #$ff
000404  1  9A                   txs
000405  1  A9 00                lda #0          ;*** test 0 = initialize
000407  1  8D 00 02             sta test_case
00040A  1               test_num .set 0
00040A  1               
00040A  1               ;stop interrupts before initializing BSS
00040A  1                   .if I_flag = 1
00040A  1                       sei
00040A  1                   .endif
00040A  1               
00040A  1               ;initialize I/O for report channel
00040A  1                   .if report = 1
00040A  1                       jsr report_init
00040A  1                   .endif
00040A  1               
00040A  1               ;pretest small branch offset
00040A  1  A2 05                ldx #5
00040C  1  4C 34 04             jmp psb_test
00040F  1               psb_bwok:
00040F  1  A0 05                ldy #5
000411  1  D0 08                bne psb_forw
000413  1  4C 13 04             trap        ;branch should be taken
000416  1  88                   dey         ;forward landing zone
000417  1  88                   dey
000418  1  88                   dey
000419  1  88                   dey
00041A  1  88                   dey
00041B  1               psb_forw:
00041B  1  88                   dey
00041C  1  88                   dey
00041D  1  88                   dey
00041E  1  88                   dey
00041F  1  88                   dey
000420  1  F0 17                beq psb_fwok
000422  1  4C 22 04             trap        ;forward offset
000425  1               
000425  1  CA                   dex         ;backward landing zone
000426  1  CA                   dex
000427  1  CA                   dex
000428  1  CA                   dex
000429  1  CA                   dex
00042A  1               psb_back:
00042A  1  CA                   dex
00042B  1  CA                   dex
00042C  1  CA                   dex
00042D  1  CA                   dex
00042E  1  CA                   dex
00042F  1  F0 DE                beq psb_bwok
000431  1  4C 31 04             trap        ;backward offset
000434  1               psb_test:
000434  1  D0 F4                bne psb_back
000436  1  4C 36 04             trap        ;branch should be taken
000439  1               psb_fwok:
000439  1               
000439  1               ;initialize BSS segment
000439  1                   .if load_data_direct <> 1
000439  1                       ldx #zp_end-zp_init-1
000439  1               ld_zp:  lda zp_init,x
000439  1                       sta zp_bss,x
000439  1                       dex
000439  1                       bpl ld_zp
000439  1                       ldx #data_end-data_init-1
000439  1               ld_data:lda data_init,x
000439  1                       sta data_bss,x
000439  1                       dex
000439  1                       bpl ld_data
000439  1                     .if ROM_vectors = 1
000439  1                       ldx #5
000439  1               ld_vect:lda vec_init,x
000439  1                       sta vec_bss,x
000439  1                       dex
000439  1                       bpl ld_vect
000439  1                     .endif
000439  1                   .endif
000439  1               
000439  1               ;retain status of interrupt flag
000439  1                   .if I_flag = 2
000439  1                       php
000439  1                       pla
000439  1                       and #4          ;isolate flag
000439  1                       sta flag_I_on   ;or mask
000439  1                       eor #lo(~4)     ;reverse
000439  1                       sta flag_I_off  ;and mask
000439  1                   .endif
000439  1               
000439  1               ;generate checksum for RAM integrity test
000439  1                   .if ram_top > -1
000439  1  A9 00                lda #0
00043B  1  85 0C                sta zpt         ;set low byte of indirect pointer
00043D  1  8D 02 02             sta ram_chksm+1 ;checksum high byte
000440  1                     .if disable_selfmod = 0
000440  1  8D 57 05             sta range_adr   ;reset self modifying code
000443  1                     .endif
000443  1  18                   clc
000444  1  A2 09                ldx #zp_bss-zero_page ;zeropage - write test area
000446  1  75 0A        gcs3:   adc zero_page,x
000448  1  90 04                bcc gcs2
00044A  1  EE 02 02             inc ram_chksm+1 ;carry to high byte
00044D  1  18                   clc
00044E  1  E8           gcs2:   inx
00044F  1  D0 F5                bne gcs3
000451  1  A2 02                ldx #.hibyte(abs1)   ;set high byte of indirect pointer
000453  1  86 0D                stx zpt+1
000455  1  A0 17                ldy #.lobyte(abs1)   ;data after write & execute test area
000457  1  71 0C        gcs5:   adc (zpt),y
000459  1  90 04                bcc gcs4
00045B  1  EE 02 02             inc ram_chksm+1 ;carry to high byte
00045E  1  18                   clc
00045F  1  C8           gcs4:   iny
000460  1  D0 F5                bne gcs5
000462  1  E8                   inx             ;advance RAM high address
000463  1  86 0D                stx zpt+1
000465  1  E0 00                cpx #ram_top
000467  1  D0 EE                bne gcs5
000469  1  8D 01 02             sta ram_chksm   ;checksum complete
00046C  1                   .endif
00046C  1  AD 00 02 C9          next_test
000470  1  00 D0 FE A9  
000474  1  01 8D 00 02  
0004B5  1               
0004B5  1                   .if disable_selfmod = 0
0004B5  1               ;testing relative addressing with BEQ
0004B5  1  A0 FE                ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0004B7  1               range_loop:
0004B7  1  88                   dey             ;next relative address
0004B8  1  98                   tya
0004B9  1  AA                   tax             ;precharge count to end of loop
0004BA  1  10 08                bpl range_fw    ;calculate relative address
0004BC  1  18                   clc             ;avoid branch self or to relative address of branch
0004BD  1  69 02                adc #2
0004BF  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
0004C0  1  EA                   nop
0004C1  1  EA                   nop
0004C2  1  EA                   nop
0004C3  1  EA                   nop
0004C4  1               range_fw:
0004C4  1  EA                   nop
0004C5  1  EA                   nop
0004C6  1  EA                   nop
0004C7  1  EA                   nop
0004C8  1  EA                   nop
0004C9  1  49 7F                eor #$7f        ;complement except sign
0004CB  1  8D 57 05             sta range_adr   ;load into test target
0004CE  1  A9 00                lda #0          ;should set zero flag in status register
0004D0  1  4C 56 05             jmp range_op
0004D3  1               
0004D3  1  CA                   dex             ; offset landing zone - backward branch too far
0004D4  1  CA                   dex
0004D5  1  CA                   dex
0004D6  1  CA                   dex
0004D7  1  CA                   dex
0004D8  1                       ;relative address target field with branch under test in the middle
0004D8  1  CA                   dex             ;-128 - max backward
0004D9  1  CA                   dex
0004DA  1  CA                   dex
0004DB  1  CA                   dex
0004DC  1  CA                   dex
0004DD  1  CA                   dex
0004DE  1  CA                   dex
0004DF  1  CA                   dex
0004E0  1  CA                   dex             ;-120
0004E1  1  CA                   dex
0004E2  1  CA                   dex
0004E3  1  CA                   dex
0004E4  1  CA                   dex
0004E5  1  CA                   dex
0004E6  1  CA                   dex
0004E7  1  CA                   dex
0004E8  1  CA                   dex
0004E9  1  CA                   dex
0004EA  1  CA                   dex             ;-110
0004EB  1  CA                   dex
0004EC  1  CA                   dex
0004ED  1  CA                   dex
0004EE  1  CA                   dex
0004EF  1  CA                   dex
0004F0  1  CA                   dex
0004F1  1  CA                   dex
0004F2  1  CA                   dex
0004F3  1  CA                   dex
0004F4  1  CA                   dex             ;-100
0004F5  1  CA                   dex
0004F6  1  CA                   dex
0004F7  1  CA                   dex
0004F8  1  CA                   dex
0004F9  1  CA                   dex
0004FA  1  CA                   dex
0004FB  1  CA                   dex
0004FC  1  CA                   dex
0004FD  1  CA                   dex
0004FE  1  CA                   dex             ;-90
0004FF  1  CA                   dex
000500  1  CA                   dex
000501  1  CA                   dex
000502  1  CA                   dex
000503  1  CA                   dex
000504  1  CA                   dex
000505  1  CA                   dex
000506  1  CA                   dex
000507  1  CA                   dex
000508  1  CA                   dex             ;-80
000509  1  CA                   dex
00050A  1  CA                   dex
00050B  1  CA                   dex
00050C  1  CA                   dex
00050D  1  CA                   dex
00050E  1  CA                   dex
00050F  1  CA                   dex
000510  1  CA                   dex
000511  1  CA                   dex
000512  1  CA                   dex             ;-70
000513  1  CA                   dex
000514  1  CA                   dex
000515  1  CA                   dex
000516  1  CA                   dex
000517  1  CA                   dex
000518  1  CA                   dex
000519  1  CA                   dex
00051A  1  CA                   dex
00051B  1  CA                   dex
00051C  1  CA                   dex             ;-60
00051D  1  CA                   dex
00051E  1  CA                   dex
00051F  1  CA                   dex
000520  1  CA                   dex
000521  1  CA                   dex
000522  1  CA                   dex
000523  1  CA                   dex
000524  1  CA                   dex
000525  1  CA                   dex
000526  1  CA                   dex             ;-50
000527  1  CA                   dex
000528  1  CA                   dex
000529  1  CA                   dex
00052A  1  CA                   dex
00052B  1  CA                   dex
00052C  1  CA                   dex
00052D  1  CA                   dex
00052E  1  CA                   dex
00052F  1  CA                   dex
000530  1  CA                   dex             ;-40
000531  1  CA                   dex
000532  1  CA                   dex
000533  1  CA                   dex
000534  1  CA                   dex
000535  1  CA                   dex
000536  1  CA                   dex
000537  1  CA                   dex
000538  1  CA                   dex
000539  1  CA                   dex
00053A  1  CA                   dex             ;-30
00053B  1  CA                   dex
00053C  1  CA                   dex
00053D  1  CA                   dex
00053E  1  CA                   dex
00053F  1  CA                   dex
000540  1  CA                   dex
000541  1  CA                   dex
000542  1  CA                   dex
000543  1  CA                   dex
000544  1  CA                   dex             ;-20
000545  1  CA                   dex
000546  1  CA                   dex
000547  1  CA                   dex
000548  1  CA                   dex
000549  1  CA                   dex
00054A  1  CA                   dex
00054B  1  CA                   dex
00054C  1  CA                   dex
00054D  1  CA                   dex
00054E  1  CA                   dex             ;-10
00054F  1  CA                   dex
000550  1  CA                   dex
000551  1  CA                   dex
000552  1  CA                   dex
000553  1  CA                   dex
000554  1  CA                   dex
000555  1  CA                   dex             ;-3
000556  1               range_op:               ;test target with zero flag=0, z=1 if previous dex
000556  1               range_adr   = *+1       ;modifiable relative address
000556  1  F0 3E                beq *+64        ;+64 if called without modification
000558  1  CA                   dex             ;+0
000559  1  CA                   dex
00055A  1  CA                   dex
00055B  1  CA                   dex
00055C  1  CA                   dex
00055D  1  CA                   dex
00055E  1  CA                   dex
00055F  1  CA                   dex
000560  1  CA                   dex
000561  1  CA                   dex
000562  1  CA                   dex             ;+10
000563  1  CA                   dex
000564  1  CA                   dex
000565  1  CA                   dex
000566  1  CA                   dex
000567  1  CA                   dex
000568  1  CA                   dex
000569  1  CA                   dex
00056A  1  CA                   dex
00056B  1  CA                   dex
00056C  1  CA                   dex             ;+20
00056D  1  CA                   dex
00056E  1  CA                   dex
00056F  1  CA                   dex
000570  1  CA                   dex
000571  1  CA                   dex
000572  1  CA                   dex
000573  1  CA                   dex
000574  1  CA                   dex
000575  1  CA                   dex
000576  1  CA                   dex             ;+30
000577  1  CA                   dex
000578  1  CA                   dex
000579  1  CA                   dex
00057A  1  CA                   dex
00057B  1  CA                   dex
00057C  1  CA                   dex
00057D  1  CA                   dex
00057E  1  CA                   dex
00057F  1  CA                   dex
000580  1  CA                   dex             ;+40
000581  1  CA                   dex
000582  1  CA                   dex
000583  1  CA                   dex
000584  1  CA                   dex
000585  1  CA                   dex
000586  1  CA                   dex
000587  1  CA                   dex
000588  1  CA                   dex
000589  1  CA                   dex
00058A  1  CA                   dex             ;+50
00058B  1  CA                   dex
00058C  1  CA                   dex
00058D  1  CA                   dex
00058E  1  CA                   dex
00058F  1  CA                   dex
000590  1  CA                   dex
000591  1  CA                   dex
000592  1  CA                   dex
000593  1  CA                   dex
000594  1  CA                   dex             ;+60
000595  1  CA                   dex
000596  1  CA                   dex
000597  1  CA                   dex
000598  1  CA                   dex
000599  1  CA                   dex
00059A  1  CA                   dex
00059B  1  CA                   dex
00059C  1  CA                   dex
00059D  1  CA                   dex
00059E  1  CA                   dex             ;+70
00059F  1  CA                   dex
0005A0  1  CA                   dex
0005A1  1  CA                   dex
0005A2  1  CA                   dex
0005A3  1  CA                   dex
0005A4  1  CA                   dex
0005A5  1  CA                   dex
0005A6  1  CA                   dex
0005A7  1  CA                   dex
0005A8  1  CA                   dex             ;+80
0005A9  1  CA                   dex
0005AA  1  CA                   dex
0005AB  1  CA                   dex
0005AC  1  CA                   dex
0005AD  1  CA                   dex
0005AE  1  CA                   dex
0005AF  1  CA                   dex
0005B0  1  CA                   dex
0005B1  1  CA                   dex
0005B2  1  CA                   dex             ;+90
0005B3  1  CA                   dex
0005B4  1  CA                   dex
0005B5  1  CA                   dex
0005B6  1  CA                   dex
0005B7  1  CA                   dex
0005B8  1  CA                   dex
0005B9  1  CA                   dex
0005BA  1  CA                   dex
0005BB  1  CA                   dex
0005BC  1  CA                   dex             ;+100
0005BD  1  CA                   dex
0005BE  1  CA                   dex
0005BF  1  CA                   dex
0005C0  1  CA                   dex
0005C1  1  CA                   dex
0005C2  1  CA                   dex
0005C3  1  CA                   dex
0005C4  1  CA                   dex
0005C5  1  CA                   dex
0005C6  1  CA                   dex             ;+110
0005C7  1  CA                   dex
0005C8  1  CA                   dex
0005C9  1  CA                   dex
0005CA  1  CA                   dex
0005CB  1  CA                   dex
0005CC  1  CA                   dex
0005CD  1  CA                   dex
0005CE  1  CA                   dex
0005CF  1  CA                   dex
0005D0  1  CA                   dex             ;+120
0005D1  1  CA                   dex
0005D2  1  CA                   dex
0005D3  1  CA                   dex
0005D4  1  CA                   dex
0005D5  1  CA                   dex
0005D6  1  CA                   dex
0005D7  1  EA                   nop             ;offset landing zone - forward branch too far
0005D8  1  EA                   nop
0005D9  1  EA                   nop
0005DA  1  EA                   nop
0005DB  1  EA                   nop
0005DC  1  F0 08                beq range_ok    ;+127 - max forward
0005DE  1  4C DE 05             trap            ; bad range
0005E1  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
0005E2  1  EA                   nop
0005E3  1  EA                   nop
0005E4  1  EA                   nop
0005E5  1  EA                   nop
0005E6  1               range_ok:
0005E6  1  EA                   nop
0005E7  1  EA                   nop
0005E8  1  EA                   nop
0005E9  1  EA                   nop
0005EA  1  EA                   nop
0005EB  1  C0 00                cpy #0
0005ED  1  F0 03                beq range_end
0005EF  1  4C B7 04             jmp range_loop
0005F2  1               range_end:              ;range test successful
0005F2  1                   .endif
0005F2  1  AD 00 02 C9          next_test
0005F6  1  01 D0 FE A9  
0005FA  1  02 8D 00 02  
00063B  1               
00063B  1               ;partial test BNE & CMP, CPX, CPY immediate
00063B  1  C0 01                cpy #1          ;testing BNE true
00063D  1  D0 03                bne test_bne
00063F  1  4C 3F 06             trap
000642  1               test_bne:
000642  1  A9 00                lda #0
000644  1  C9 00                cmp #0          ;test compare immediate
000646  1  D0 FE                trap_ne
000648  1  90 FE                trap_cc
00064A  1  30 FE                trap_mi
00064C  1  C9 01                cmp #1
00064E  1  F0 FE                trap_eq
000650  1  B0 FE                trap_cs
000652  1  10 FE                trap_pl
000654  1  AA                   tax
000655  1  E0 00                cpx #0          ;test compare x immediate
000657  1  D0 FE                trap_ne
000659  1  90 FE                trap_cc
00065B  1  30 FE                trap_mi
00065D  1  E0 01                cpx #1
00065F  1  F0 FE                trap_eq
000661  1  B0 FE                trap_cs
000663  1  10 FE                trap_pl
000665  1  A8                   tay
000666  1  C0 00                cpy #0          ;test compare y immediate
000668  1  D0 FE                trap_ne
00066A  1  90 FE                trap_cc
00066C  1  30 FE                trap_mi
00066E  1  C0 01                cpy #1
000670  1  F0 FE                trap_eq
000672  1  B0 FE                trap_cs
000674  1  10 FE                trap_pl
000676  1  AD 00 02 C9          next_test
00067A  1  02 D0 FE A9  
00067E  1  03 8D 00 02  
0006BF  1               ;testing stack operations PHA PHP PLA PLP
0006BF  1               
0006BF  1  A2 FF                ldx #$ff        ;initialize stack
0006C1  1  9A                   txs
0006C2  1  A9 55                lda #$55
0006C4  1  48                   pha
0006C5  1  A9 AA                lda #$aa
0006C7  1  48                   pha
0006C8  1  CD FE 01             cmp $1fe        ;on stack ?
0006CB  1  D0 FE                trap_ne
0006CD  1  BA                   tsx
0006CE  1  8A                   txa             ;overwrite accu
0006CF  1  C9 FD                cmp #$fd        ;sp decremented?
0006D1  1  D0 FE                trap_ne
0006D3  1  68                   pla
0006D4  1  C9 AA                cmp #$aa        ;successful retreived from stack?
0006D6  1  D0 FE                trap_ne
0006D8  1  68                   pla
0006D9  1  C9 55                cmp #$55
0006DB  1  D0 FE                trap_ne
0006DD  1  CD FF 01             cmp $1ff        ;remains on stack?
0006E0  1  D0 FE                trap_ne
0006E2  1  BA                   tsx
0006E3  1  E0 FF                cpx #$ff        ;sp incremented?
0006E5  1  D0 FE                trap_ne
0006E7  1  AD 00 02 C9          next_test
0006EB  1  03 D0 FE A9  
0006EF  1  04 8D 00 02  
000730  1               
000730  1               ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
000730  1  A9 FF 48 28          set_stat $ff    ;all on
000734  1  10 1A                bpl nbr1        ;branches should not be taken
000736  1  50 1B                bvc nbr2
000738  1  90 1C                bcc nbr3
00073A  1  D0 1D                bne nbr4
00073C  1  30 03                bmi br1         ;branches should be taken
00073E  1  4C 3E 07             trap
000741  1  70 03        br1:    bvs br2
000743  1  4C 43 07             trap
000746  1  B0 03        br2:    bcs br3
000748  1  4C 48 07             trap
00074B  1  F0 0F        br3:    beq br4
00074D  1  4C 4D 07             trap
000750  1               nbr1:
000750  1  4C 50 07             trap            ;previous bpl taken
000753  1               nbr2:
000753  1  4C 53 07             trap            ;previous bvc taken
000756  1               nbr3:
000756  1  4C 56 07             trap            ;previous bcc taken
000759  1               nbr4:
000759  1  4C 59 07             trap            ;previous bne taken
00075C  1  08           br4:    php
00075D  1  BA                   tsx
00075E  1  E0 FE                cpx #$fe        ;sp after php?
000760  1  D0 FE                trap_ne
000762  1  68                   pla
000763  1  C9 FF                cmp_flag $ff    ;returned all flags on?
000765  1  D0 FE                trap_ne
000767  1  BA                   tsx
000768  1  E0 FF                cpx #$ff        ;sp after php?
00076A  1  D0 FE                trap_ne
00076C  1  A9 00 48 28          set_stat 0      ;all off
000770  1  30 1A                bmi nbr11       ;branches should not be taken
000772  1  70 1B                bvs nbr12
000774  1  B0 1C                bcs nbr13
000776  1  F0 1D                beq nbr14
000778  1  10 03                bpl br11        ;branches should be taken
00077A  1  4C 7A 07             trap
00077D  1  50 03        br11:   bvc br12
00077F  1  4C 7F 07             trap
000782  1  90 03        br12:   bcc br13
000784  1  4C 84 07             trap
000787  1  D0 0F        br13:   bne br14
000789  1  4C 89 07             trap
00078C  1               nbr11:
00078C  1  4C 8C 07             trap            ;previous bmi taken
00078F  1               nbr12:
00078F  1  4C 8F 07             trap            ;previous bvs taken
000792  1               nbr13:
000792  1  4C 92 07             trap            ;previous bcs taken
000795  1               nbr14:
000795  1  4C 95 07             trap            ;previous beq taken
000798  1  08           br14:   php
000799  1  68                   pla
00079A  1  C9 30                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
00079C  1  D0 FE                trap_ne
00079E  1                       ;crosscheck flags
00079E  1  A9 02 48 28          set_stat zero
0007A2  1  D0 02                bne brzs1
0007A4  1  F0 03                beq brzs2
0007A6  1               brzs1:
0007A6  1  4C A6 07             trap            ;branch zero/non zero
0007A9  1  B0 02        brzs2:  bcs brzs3
0007AB  1  90 03                bcc brzs4
0007AD  1               brzs3:
0007AD  1  4C AD 07             trap            ;branch carry/no carry
0007B0  1  30 02        brzs4:  bmi brzs5
0007B2  1  10 03                bpl brzs6
0007B4  1               brzs5:
0007B4  1  4C B4 07             trap            ;branch minus/plus
0007B7  1  70 02        brzs6:  bvs brzs7
0007B9  1  50 03                bvc brzs8
0007BB  1               brzs7:
0007BB  1  4C BB 07             trap            ;branch overflow/no overflow
0007BE  1               brzs8:
0007BE  1  A9 01 48 28          set_stat carry
0007C2  1  F0 02                beq brcs1
0007C4  1  D0 03                bne brcs2
0007C6  1               brcs1:
0007C6  1  4C C6 07             trap            ;branch zero/non zero
0007C9  1  90 02        brcs2:  bcc brcs3
0007CB  1  B0 03                bcs brcs4
0007CD  1               brcs3:
0007CD  1  4C CD 07             trap            ;branch carry/no carry
0007D0  1  30 02        brcs4:  bmi brcs5
0007D2  1  10 03                bpl brcs6
0007D4  1               brcs5:
0007D4  1  4C D4 07             trap            ;branch minus/plus
0007D7  1  70 02        brcs6:  bvs brcs7
0007D9  1  50 03                bvc brcs8
0007DB  1               brcs7:
0007DB  1  4C DB 07             trap            ;branch overflow/no overflow
0007DE  1               
0007DE  1               brcs8:
0007DE  1  A9 80 48 28          set_stat minus
0007E2  1  F0 02                beq brmi1
0007E4  1  D0 03                bne brmi2
0007E6  1               brmi1:
0007E6  1  4C E6 07             trap            ;branch zero/non zero
0007E9  1  B0 02        brmi2:  bcs brmi3
0007EB  1  90 03                bcc brmi4
0007ED  1               brmi3:
0007ED  1  4C ED 07             trap            ;branch carry/no carry
0007F0  1  10 02        brmi4:  bpl brmi5
0007F2  1  30 03                bmi brmi6
0007F4  1               brmi5:
0007F4  1  4C F4 07             trap            ;branch minus/plus
0007F7  1  70 02        brmi6:  bvs brmi7
0007F9  1  50 03                bvc brmi8
0007FB  1               brmi7:
0007FB  1  4C FB 07             trap            ;branch overflow/no overflow
0007FE  1               brmi8:
0007FE  1  A9 40 48 28          set_stat overfl
000802  1  F0 02                beq brvs1
000804  1  D0 03                bne brvs2
000806  1               brvs1:
000806  1  4C 06 08             trap            ;branch zero/non zero
000809  1  B0 02        brvs2:  bcs brvs3
00080B  1  90 03                bcc brvs4
00080D  1               brvs3:
00080D  1  4C 0D 08             trap            ;branch carry/no carry
000810  1  30 02        brvs4:  bmi brvs5
000812  1  10 03                bpl brvs6
000814  1               brvs5:
000814  1  4C 14 08             trap            ;branch minus/plus
000817  1  50 02        brvs6:  bvc brvs7
000819  1  70 03                bvs brvs8
00081B  1               brvs7:
00081B  1  4C 1B 08             trap            ;branch overflow/no overflow
00081E  1               brvs8:
00081E  1  A9 FD 48 28          set_stat $ff-zero
000822  1  F0 02                beq brzc1
000824  1  D0 03                bne brzc2
000826  1               brzc1:
000826  1  4C 26 08             trap            ;branch zero/non zero
000829  1  90 02        brzc2:  bcc brzc3
00082B  1  B0 03                bcs brzc4
00082D  1               brzc3:
00082D  1  4C 2D 08             trap            ;branch carry/no carry
000830  1  10 02        brzc4:  bpl brzc5
000832  1  30 03                bmi brzc6
000834  1               brzc5:
000834  1  4C 34 08             trap            ;branch minus/plus
000837  1  50 02        brzc6:  bvc brzc7
000839  1  70 03                bvs brzc8
00083B  1               brzc7:
00083B  1  4C 3B 08             trap            ;branch overflow/no overflow
00083E  1               brzc8:
00083E  1  A9 FE 48 28          set_stat $ff-carry
000842  1  D0 02                bne brcc1
000844  1  F0 03                beq brcc2
000846  1               brcc1:
000846  1  4C 46 08             trap            ;branch zero/non zero
000849  1  B0 02        brcc2:  bcs brcc3
00084B  1  90 03                bcc brcc4
00084D  1               brcc3:
00084D  1  4C 4D 08             trap            ;branch carry/no carry
000850  1  10 02        brcc4:  bpl brcc5
000852  1  30 03                bmi brcc6
000854  1               brcc5:
000854  1  4C 54 08             trap            ;branch minus/plus
000857  1  50 02        brcc6:  bvc brcc7
000859  1  70 03                bvs brcc8
00085B  1               brcc7:
00085B  1  4C 5B 08             trap            ;branch overflow/no overflow
00085E  1               brcc8:
00085E  1  A9 7F 48 28          set_stat $ff-minus
000862  1  D0 02                bne brpl1
000864  1  F0 03                beq brpl2
000866  1               brpl1:
000866  1  4C 66 08             trap            ;branch zero/non zero
000869  1  90 02        brpl2:  bcc brpl3
00086B  1  B0 03                bcs brpl4
00086D  1               brpl3:
00086D  1  4C 6D 08             trap            ;branch carry/no carry
000870  1  30 02        brpl4:  bmi brpl5
000872  1  10 03                bpl brpl6
000874  1               brpl5:
000874  1  4C 74 08             trap            ;branch minus/plus
000877  1  50 02        brpl6:  bvc brpl7
000879  1  70 03                bvs brpl8
00087B  1               brpl7:
00087B  1  4C 7B 08             trap            ;branch overflow/no overflow
00087E  1               brpl8:
00087E  1  A9 BF 48 28          set_stat $ff-overfl
000882  1  D0 02                bne brvc1
000884  1  F0 03                beq brvc2
000886  1               brvc1:
000886  1  4C 86 08             trap            ;branch zero/non zero
000889  1  90 02        brvc2:  bcc brvc3
00088B  1  B0 03                bcs brvc4
00088D  1               brvc3:
00088D  1  4C 8D 08             trap            ;branch carry/no carry
000890  1  10 02        brvc4:  bpl brvc5
000892  1  30 03                bmi brvc6
000894  1               brvc5:
000894  1  4C 94 08             trap            ;branch minus/plus
000897  1  70 02        brvc6:  bvs brvc7
000899  1  50 03                bvc brvc8
00089B  1               brvc7:
00089B  1  4C 9B 08             trap            ;branch overflow/no overflow
00089E  1               brvc8:
00089E  1  AD 00 02 C9          next_test
0008A2  1  04 D0 FE A9  
0008A6  1  05 8D 00 02  
0008E7  1               
0008E7  1               ; test PHA does not alter flags or accumulator but PLA does
0008E7  1  A2 55                ldx #$55        ;x & y protected
0008E9  1  A0 AA                ldy #$aa
0008EB  1  A9 FF 48 A9          set_a 1,$ff     ;push
0008EF  1  01 28        
0008F1  1  48                   pha
0008F2  1  08 C9 01 D0          tst_a 1,$ff
0008F6  1  FE 68 48 C9  
0008FA  1  FF D0 FE 28  
0008FE  1  A9 00 48 A9          set_a 0,0
000902  1  00 28        
000904  1  48                   pha
000905  1  08 C9 00 D0          tst_a 0,0
000909  1  FE 68 48 C9  
00090D  1  30 D0 FE 28  
000911  1  A9 FF 48 A9          set_a $ff,$ff
000915  1  FF 28        
000917  1  48                   pha
000918  1  08 C9 FF D0          tst_a $ff,$ff
00091C  1  FE 68 48 C9  
000920  1  FF D0 FE 28  
000924  1  A9 00 48 A9          set_a 1,0
000928  1  01 28        
00092A  1  48                   pha
00092B  1  08 C9 01 D0          tst_a 1,0
00092F  1  FE 68 48 C9  
000933  1  30 D0 FE 28  
000937  1  A9 FF 48 A9          set_a 0,$ff
00093B  1  00 28        
00093D  1  48                   pha
00093E  1  08 C9 00 D0          tst_a 0,$ff
000942  1  FE 68 48 C9  
000946  1  FF D0 FE 28  
00094A  1  A9 00 48 A9          set_a $ff,0
00094E  1  FF 28        
000950  1  48                   pha
000951  1  08 C9 FF D0          tst_a $ff,0
000955  1  FE 68 48 C9  
000959  1  30 D0 FE 28  
00095D  1  A9 FF 48 A9          set_a 0,$ff     ;pull
000961  1  00 28        
000963  1  68                   pla
000964  1  08 C9 FF D0          tst_a $ff,$ff-zero
000968  1  FE 68 48 C9  
00096C  1  FD D0 FE 28  
000970  1  A9 00 48 A9          set_a $ff,0
000974  1  FF 28        
000976  1  68                   pla
000977  1  08 C9 00 D0          tst_a 0,zero
00097B  1  FE 68 48 C9  
00097F  1  32 D0 FE 28  
000983  1  A9 FF 48 A9          set_a $fe,$ff
000987  1  FE 28        
000989  1  68                   pla
00098A  1  08 C9 01 D0          tst_a 1,$ff-zero-minus
00098E  1  FE 68 48 C9  
000992  1  7D D0 FE 28  
000996  1  A9 00 48 A9          set_a 0,0
00099A  1  00 28        
00099C  1  68                   pla
00099D  1  08 C9 FF D0          tst_a $ff,minus
0009A1  1  FE 68 48 C9  
0009A5  1  B0 D0 FE 28  
0009A9  1  A9 FF 48 A9          set_a $ff,$ff
0009AD  1  FF 28        
0009AF  1  68                   pla
0009B0  1  08 C9 00 D0          tst_a 0,$ff-minus
0009B4  1  FE 68 48 C9  
0009B8  1  7F D0 FE 28  
0009BC  1  A9 00 48 A9          set_a $fe,0
0009C0  1  FE 28        
0009C2  1  68                   pla
0009C3  1  08 C9 01 D0          tst_a 1,0
0009C7  1  FE 68 48 C9  
0009CB  1  30 D0 FE 28  
0009CF  1  E0 55                cpx #$55        ;x & y unchanged?
0009D1  1  D0 FE                trap_ne
0009D3  1  C0 AA                cpy #$aa
0009D5  1  D0 FE                trap_ne
0009D7  1  AD 00 02 C9          next_test
0009DB  1  05 D0 FE A9  
0009DF  1  06 8D 00 02  
000A20  1               
000A20  1               ; partial pretest EOR #
000A20  1  A9 00 48 A9          set_a $3c,0
000A24  1  3C 28        
000A26  1  49 C3                eor #$c3
000A28  1  08 C9 FF D0          tst_a $ff,fn
000A2C  1  FE 68 48 C9  
000A30  1  B0 D0 FE 28  
000A34  1  A9 00 48 A9          set_a $c3,0
000A38  1  C3 28        
000A3A  1  49 C3                eor #$c3
000A3C  1  08 C9 00 D0          tst_a 0,fz
000A40  1  FE 68 48 C9  
000A44  1  32 D0 FE 28  
000A48  1  AD 00 02 C9          next_test
000A4C  1  06 D0 FE A9  
000A50  1  07 8D 00 02  
000A91  1               
000A91  1               ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
000A91  1               ; testing NOP
000A91  1  A2 24                ldx #$24
000A93  1  A0 42                ldy #$42
000A95  1  A9 00 48 A9          set_a $18,0
000A99  1  18 28        
000A9B  1  EA                   nop
000A9C  1  08 C9 18 D0          tst_a $18,0
000AA0  1  FE 68 48 C9  
000AA4  1  30 D0 FE 28  
000AA8  1  E0 24                cpx #$24
000AAA  1  D0 FE                trap_ne
000AAC  1  C0 42                cpy #$42
000AAE  1  D0 FE                trap_ne
000AB0  1  A2 DB                ldx #$db
000AB2  1  A0 BD                ldy #$bd
000AB4  1  A9 FF 48 A9          set_a $e7,$ff
000AB8  1  E7 28        
000ABA  1  EA                   nop
000ABB  1  08 C9 E7 D0          tst_a $e7,$ff
000ABF  1  FE 68 48 C9  
000AC3  1  FF D0 FE 28  
000AC7  1  E0 DB                cpx #$db
000AC9  1  D0 FE                trap_ne
000ACB  1  C0 BD                cpy #$bd
000ACD  1  D0 FE                trap_ne
000ACF  1  AD 00 02 C9          next_test
000AD3  1  07 D0 FE A9  
000AD7  1  08 8D 00 02  
000B18  1               
000B18  1               ; jump absolute
000B18  1  A9 00 48 28          set_stat $0
000B1C  1  A9 46                lda #'F'
000B1E  1  A2 41                ldx #'A'
000B20  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
000B22  1  4C F6 3E             jmp test_far
000B25  1  EA                   nop
000B26  1  EA                   nop
000B27  1  D0 FE                trap_ne         ;runover protection
000B29  1  E8                   inx
000B2A  1  E8                   inx
000B2B  1               far_ret:
000B2B  1  F0 FE                trap_eq         ;returned flags OK?
000B2D  1  10 FE                trap_pl
000B2F  1  90 FE                trap_cc
000B31  1  50 FE                trap_vc
000B33  1  C9 EC                cmp #('F'^$aa)  ;returned registers OK?
000B35  1  D0 FE                trap_ne
000B37  1  E0 42                cpx #('A'+1)
000B39  1  D0 FE                trap_ne
000B3B  1  C0 4F                cpy #('R'-3)
000B3D  1  D0 FE                trap_ne
000B3F  1  CA                   dex
000B40  1  C8                   iny
000B41  1  C8                   iny
000B42  1  C8                   iny
000B43  1  49 AA                eor #$aa        ;N=0, V=1, Z=0, C=1
000B45  1  4C 4E 0B             jmp test_near
000B48  1  EA                   nop
000B49  1  EA                   nop
000B4A  1  D0 FE                trap_ne         ;runover protection
000B4C  1  E8                   inx
000B4D  1  E8                   inx
000B4E  1               test_near:
000B4E  1  F0 FE                trap_eq         ;passed flags OK?
000B50  1  30 FE                trap_mi
000B52  1  90 FE                trap_cc
000B54  1  50 FE                trap_vc
000B56  1  C9 46                cmp #'F'        ;passed registers OK?
000B58  1  D0 FE                trap_ne
000B5A  1  E0 41                cpx #'A'
000B5C  1  D0 FE                trap_ne
000B5E  1  C0 52                cpy #'R'
000B60  1  D0 FE                trap_ne
000B62  1  AD 00 02 C9          next_test
000B66  1  08 D0 FE A9  
000B6A  1  09 8D 00 02  
000BAB  1               
000BAB  1               ; jump indirect
000BAB  1  A9 00 48 28          set_stat 0
000BAF  1  A9 49                lda #'I'
000BB1  1  A2 4E                ldx #'N'
000BB3  1  A0 44                ldy #'D'        ;N=0, V=0, Z=0, C=0
000BB5  1  6C 24 3F             jmp (ptr_tst_ind)
000BB8  1  EA                   nop
000BB9  1  D0 FE                trap_ne         ;runover protection
000BBB  1  88                   dey
000BBC  1  88                   dey
000BBD  1               ind_ret:
000BBD  1  08                   php             ;either SP or Y count will fail, if we do not hit
000BBE  1  88                   dey
000BBF  1  88                   dey
000BC0  1  88                   dey
000BC1  1  28                   plp
000BC2  1  F0 FE                trap_eq         ;returned flags OK?
000BC4  1  10 FE                trap_pl
000BC6  1  90 FE                trap_cc
000BC8  1  50 FE                trap_vc
000BCA  1  C9 E3                cmp #('I'^$aa)  ;returned registers OK?
000BCC  1  D0 FE                trap_ne
000BCE  1  E0 4F                cpx #('N'+1)
000BD0  1  D0 FE                trap_ne
000BD2  1  C0 3E                cpy #('D'-6)
000BD4  1  D0 FE                trap_ne
000BD6  1  BA                   tsx             ;SP check
000BD7  1  E0 FF                cpx #$ff
000BD9  1  D0 FE                trap_ne
000BDB  1  AD 00 02 C9          next_test
000BDF  1  09 D0 FE A9  
000BE3  1  0A 8D 00 02  
000C24  1               
000C24  1               ; jump subroutine & return from subroutine
000C24  1  A9 00 48 28          set_stat 0
000C28  1  A9 4A                lda #'J'
000C2A  1  A2 53                ldx #'S'
000C2C  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
000C2E  1  20 63 3F             jsr test_jsr
000C31  1               jsr_ret = *-1           ;last address of jsr = return address
000C31  1  08                   php             ;either SP or Y count will fail, if we do not hit
000C32  1  88                   dey
000C33  1  88                   dey
000C34  1  88                   dey
000C35  1  28                   plp
000C36  1  F0 FE                trap_eq         ;returned flags OK?
000C38  1  10 FE                trap_pl
000C3A  1  90 FE                trap_cc
000C3C  1  50 FE                trap_vc
000C3E  1  C9 E0                cmp #('J'^$aa)  ;returned registers OK?
000C40  1  D0 FE                trap_ne
000C42  1  E0 54                cpx #('S'+1)
000C44  1  D0 FE                trap_ne
000C46  1  C0 4C                cpy #('R'-6)
000C48  1  D0 FE                trap_ne
000C4A  1  BA                   tsx             ;sp?
000C4B  1  E0 FF                cpx #$ff
000C4D  1  D0 FE                trap_ne
000C4F  1  AD 00 02 C9          next_test
000C53  1  0A D0 FE A9  
000C57  1  0B 8D 00 02  
000C98  1               
000C98  1               ; break & return from interrupt
000C98  1                   .if ROM_vectors = 1
000C98  1  A9 00                load_flag 0     ;with interrupts enabled if allowed!
000C9A  1  48                   pha
000C9B  1  A9 42                lda #'B'
000C9D  1  A2 52                ldx #'R'
000C9F  1  A0 4B                ldy #'K'
000CA1  1  28                   plp             ;N=0, V=0, Z=0, C=0
000CA2  1  00                   brk
000CA3  1                   .else
000CA3  1                       lda #>brk_ret0 ;emulated break
000CA3  1                       pha
000CA3  1                       lda #<brk_ret0
000CA3  1                       pha
000CA3  1                       load_flag fao    ;set break & unused on stack
000CA3  1                       pha
000CA3  1                       load_flag intdis ;during interrupt
000CA3  1                       pha
000CA3  1                       lda #'B'
000CA3  1                       ldx #'R'
000CA3  1                       ldy #'K'
000CA3  1                       plp             ;N=0, V=0, Z=0, C=0
000CA3  1                       jmp irq_trap
000CA3  1                   .endif
000CA3  1  88                   dey             ;should not be executed
000CA4  1               brk_ret0:               ;address of break return
000CA4  1  08                   php             ;either SP or Y count will fail, if we do not hit
000CA5  1  88                   dey
000CA6  1  88                   dey
000CA7  1  88                   dey
000CA8  1  C9 E8                cmp #'B'^$aa    ;returned registers OK?
000CAA  1                       ;the IRQ vector was never executed if A & X stay unmodified
000CAA  1  D0 FE                trap_ne
000CAC  1  E0 53                cpx #'R'+1
000CAE  1  D0 FE                trap_ne
000CB0  1  C0 45                cpy #'K'-6
000CB2  1  D0 FE                trap_ne
000CB4  1  68                   pla             ;returned flags OK (unchanged)?
000CB5  1  C9 30                cmp_flag 0
000CB7  1  D0 FE                trap_ne
000CB9  1  BA                   tsx             ;sp?
000CBA  1  E0 FF                cpx #$ff
000CBC  1  D0 FE                trap_ne
000CBE  1                   .if ROM_vectors = 1
000CBE  1  A9 FF                load_flag $ff   ;with interrupts disabled if allowed!
000CC0  1  48                   pha
000CC1  1  A9 BD                lda #$ff-'B'
000CC3  1  A2 AD                ldx #$ff-'R'
000CC5  1  A0 B4                ldy #$ff-'K'
000CC7  1  28                   plp             ;N=1, V=1, Z=1, C=1
000CC8  1  00                   brk
000CC9  1                   .else
000CC9  1                       lda #>brk_ret1 ;emulated break
000CC9  1                       pha
000CC9  1                       lda #<brk_ret1
000CC9  1                       pha
000CC9  1                       load_flag $ff
000CC9  1                       pha             ;set break & unused on stack
000CC9  1                       pha             ;actual flags
000CC9  1                       lda #$ff-'B'
000CC9  1                       ldx #$ff-'R'
000CC9  1                       ldy #$ff-'K'
000CC9  1                       plp             ;N=1, V=1, Z=1, C=1
000CC9  1                       jmp irq_trap
000CC9  1                   .endif
000CC9  1  88                   dey             ;should not be executed
000CCA  1               brk_ret1:               ;address of break return
000CCA  1  08                   php             ;either SP or Y count will fail, if we do not hit
000CCB  1  88                   dey
000CCC  1  88                   dey
000CCD  1  88                   dey
000CCE  1  C9 17                cmp #($ff-'B')^$aa  ;returned registers OK?
000CD0  1                       ;the IRQ vector was never executed if A & X stay unmodified
000CD0  1  D0 FE                trap_ne
000CD2  1  E0 AE                cpx #$ff-'R'+1
000CD4  1  D0 FE                trap_ne
000CD6  1  C0 AE                cpy #$ff-'K'-6
000CD8  1  D0 FE                trap_ne
000CDA  1  68                   pla             ;returned flags OK (unchanged)?
000CDB  1  C9 FF                cmp_flag $ff
000CDD  1  D0 FE                trap_ne
000CDF  1  BA                   tsx             ;sp?
000CE0  1  E0 FF                cpx #$ff
000CE2  1  D0 FE                trap_ne
000CE4  1  AD 00 02 C9          next_test
000CE8  1  0B D0 FE A9  
000CEC  1  0C 8D 00 02  
000D2D  1               
000D2D  1               ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
000D2D  1  A9 FF 48 28          set_stat $ff
000D31  1  18                   clc
000D32  1  08 68 48 C9          tst_stat $ff-carry
000D36  1  FE D0 FE 28  
000D3A  1  38                   sec
000D3B  1  08 68 48 C9          tst_stat $ff
000D3F  1  FF D0 FE 28  
000D43  1                   .if I_flag = 3
000D43  1  58                   cli
000D44  1  08 68 48 C9          tst_stat $ff-intdis
000D48  1  FB D0 FE 28  
000D4C  1  78                   sei
000D4D  1  08 68 48 C9          tst_stat $ff
000D51  1  FF D0 FE 28  
000D55  1                   .endif
000D55  1  D8                   cld
000D56  1  08 68 48 C9          tst_stat $ff-decmode
000D5A  1  F7 D0 FE 28  
000D5E  1  F8                   sed
000D5F  1  08 68 48 C9          tst_stat $ff
000D63  1  FF D0 FE 28  
000D67  1  B8                   clv
000D68  1  08 68 48 C9          tst_stat $ff-overfl
000D6C  1  BF D0 FE 28  
000D70  1  A9 00 48 28          set_stat 0
000D74  1  08 68 48 C9          tst_stat 0
000D78  1  30 D0 FE 28  
000D7C  1  38                   sec
000D7D  1  08 68 48 C9          tst_stat carry
000D81  1  31 D0 FE 28  
000D85  1  18                   clc
000D86  1  08 68 48 C9          tst_stat 0
000D8A  1  30 D0 FE 28  
000D8E  1                   .if I_flag = 3
000D8E  1  78                   sei
000D8F  1  08 68 48 C9          tst_stat intdis
000D93  1  34 D0 FE 28  
000D97  1  58                   cli
000D98  1  08 68 48 C9          tst_stat 0
000D9C  1  30 D0 FE 28  
000DA0  1                   .endif
000DA0  1  F8                   sed
000DA1  1  08 68 48 C9          tst_stat decmode
000DA5  1  38 D0 FE 28  
000DA9  1  D8                   cld
000DAA  1  08 68 48 C9          tst_stat 0
000DAE  1  30 D0 FE 28  
000DB2  1  A9 40 48 28          set_stat overfl
000DB6  1  08 68 48 C9          tst_stat overfl
000DBA  1  70 D0 FE 28  
000DBE  1  B8                   clv
000DBF  1  08 68 48 C9          tst_stat 0
000DC3  1  30 D0 FE 28  
000DC7  1  AD 00 02 C9          next_test
000DCB  1  0C D0 FE A9  
000DCF  1  0D 8D 00 02  
000E10  1               ; testing index register increment/decrement and transfer
000E10  1               ; INX INY DEX DEY TAX TXA TAY TYA
000E10  1  A2 FE                ldx #$fe
000E12  1  A9 FF 48 28          set_stat $ff
000E16  1  E8                   inx             ;ff
000E17  1  08 E0 FF D0          tst_x $ff,$ff-zero
000E1B  1  FE 68 48 C9  
000E1F  1  FD D0 FE 28  
000E23  1  E8                   inx             ;00
000E24  1  08 E0 00 D0          tst_x 0,$ff-minus
000E28  1  FE 68 48 C9  
000E2C  1  7F D0 FE 28  
000E30  1  E8                   inx             ;01
000E31  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
000E35  1  FE 68 48 C9  
000E39  1  7D D0 FE 28  
000E3D  1  CA                   dex             ;00
000E3E  1  08 E0 00 D0          tst_x 0,$ff-minus
000E42  1  FE 68 48 C9  
000E46  1  7F D0 FE 28  
000E4A  1  CA                   dex             ;ff
000E4B  1  08 E0 FF D0          tst_x $ff,$ff-zero
000E4F  1  FE 68 48 C9  
000E53  1  FD D0 FE 28  
000E57  1  CA                   dex             ;fe
000E58  1  A9 00 48 28          set_stat 0
000E5C  1  E8                   inx             ;ff
000E5D  1  08 E0 FF D0          tst_x $ff,minus
000E61  1  FE 68 48 C9  
000E65  1  B0 D0 FE 28  
000E69  1  E8                   inx             ;00
000E6A  1  08 E0 00 D0          tst_x 0,zero
000E6E  1  FE 68 48 C9  
000E72  1  32 D0 FE 28  
000E76  1  E8                   inx             ;01
000E77  1  08 E0 01 D0          tst_x 1,0
000E7B  1  FE 68 48 C9  
000E7F  1  30 D0 FE 28  
000E83  1  CA                   dex             ;00
000E84  1  08 E0 00 D0          tst_x 0,zero
000E88  1  FE 68 48 C9  
000E8C  1  32 D0 FE 28  
000E90  1  CA                   dex             ;ff
000E91  1  08 E0 FF D0          tst_x $ff,minus
000E95  1  FE 68 48 C9  
000E99  1  B0 D0 FE 28  
000E9D  1               
000E9D  1  A0 FE                ldy #$fe
000E9F  1  A9 FF 48 28          set_stat $ff
000EA3  1  C8                   iny             ;ff
000EA4  1  08 C0 FF D0          tst_y $ff,$ff-zero
000EA8  1  FE 68 48 C9  
000EAC  1  FD D0 FE 28  
000EB0  1  C8                   iny             ;00
000EB1  1  08 C0 00 D0          tst_y 0,$ff-minus
000EB5  1  FE 68 48 C9  
000EB9  1  7F D0 FE 28  
000EBD  1  C8                   iny             ;01
000EBE  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
000EC2  1  FE 68 48 C9  
000EC6  1  7D D0 FE 28  
000ECA  1  88                   dey             ;00
000ECB  1  08 C0 00 D0          tst_y 0,$ff-minus
000ECF  1  FE 68 48 C9  
000ED3  1  7F D0 FE 28  
000ED7  1  88                   dey             ;ff
000ED8  1  08 C0 FF D0          tst_y $ff,$ff-zero
000EDC  1  FE 68 48 C9  
000EE0  1  FD D0 FE 28  
000EE4  1  88                   dey             ;fe
000EE5  1  A9 00 48 28          set_stat 0
000EE9  1  C8                   iny             ;ff
000EEA  1  08 C0 FF D0          tst_y $ff,0+minus
000EEE  1  FE 68 48 C9  
000EF2  1  B0 D0 FE 28  
000EF6  1  C8                   iny             ;00
000EF7  1  08 C0 00 D0          tst_y 0,zero
000EFB  1  FE 68 48 C9  
000EFF  1  32 D0 FE 28  
000F03  1  C8                   iny             ;01
000F04  1  08 C0 01 D0          tst_y 1,0
000F08  1  FE 68 48 C9  
000F0C  1  30 D0 FE 28  
000F10  1  88                   dey             ;00
000F11  1  08 C0 00 D0          tst_y 0,zero
000F15  1  FE 68 48 C9  
000F19  1  32 D0 FE 28  
000F1D  1  88                   dey             ;ff
000F1E  1  08 C0 FF D0          tst_y $ff,minus
000F22  1  FE 68 48 C9  
000F26  1  B0 D0 FE 28  
000F2A  1               
000F2A  1  A2 FF                ldx #$ff
000F2C  1  A9 FF 48 28          set_stat $ff
000F30  1  8A                   txa
000F31  1  08 C9 FF D0          tst_a $ff,$ff-zero
000F35  1  FE 68 48 C9  
000F39  1  FD D0 FE 28  
000F3D  1  08                   php
000F3E  1  E8                   inx             ;00
000F3F  1  28                   plp
000F40  1  8A                   txa
000F41  1  08 C9 00 D0          tst_a 0,$ff-minus
000F45  1  FE 68 48 C9  
000F49  1  7F D0 FE 28  
000F4D  1  08                   php
000F4E  1  E8                   inx             ;01
000F4F  1  28                   plp
000F50  1  8A                   txa
000F51  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000F55  1  FE 68 48 C9  
000F59  1  7D D0 FE 28  
000F5D  1  A9 00 48 28          set_stat 0
000F61  1  8A                   txa
000F62  1  08 C9 01 D0          tst_a 1,0
000F66  1  FE 68 48 C9  
000F6A  1  30 D0 FE 28  
000F6E  1  08                   php
000F6F  1  CA                   dex             ;00
000F70  1  28                   plp
000F71  1  8A                   txa
000F72  1  08 C9 00 D0          tst_a 0,zero
000F76  1  FE 68 48 C9  
000F7A  1  32 D0 FE 28  
000F7E  1  08                   php
000F7F  1  CA                   dex             ;ff
000F80  1  28                   plp
000F81  1  8A                   txa
000F82  1  08 C9 FF D0          tst_a $ff,minus
000F86  1  FE 68 48 C9  
000F8A  1  B0 D0 FE 28  
000F8E  1               
000F8E  1  A0 FF                ldy #$ff
000F90  1  A9 FF 48 28          set_stat $ff
000F94  1  98                   tya
000F95  1  08 C9 FF D0          tst_a $ff,$ff-zero
000F99  1  FE 68 48 C9  
000F9D  1  FD D0 FE 28  
000FA1  1  08                   php
000FA2  1  C8                   iny             ;00
000FA3  1  28                   plp
000FA4  1  98                   tya
000FA5  1  08 C9 00 D0          tst_a 0,$ff-minus
000FA9  1  FE 68 48 C9  
000FAD  1  7F D0 FE 28  
000FB1  1  08                   php
000FB2  1  C8                   iny             ;01
000FB3  1  28                   plp
000FB4  1  98                   tya
000FB5  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000FB9  1  FE 68 48 C9  
000FBD  1  7D D0 FE 28  
000FC1  1  A9 00 48 28          set_stat 0
000FC5  1  98                   tya
000FC6  1  08 C9 01 D0          tst_a 1,0
000FCA  1  FE 68 48 C9  
000FCE  1  30 D0 FE 28  
000FD2  1  08                   php
000FD3  1  88                   dey             ;00
000FD4  1  28                   plp
000FD5  1  98                   tya
000FD6  1  08 C9 00 D0          tst_a 0,zero
000FDA  1  FE 68 48 C9  
000FDE  1  32 D0 FE 28  
000FE2  1  08                   php
000FE3  1  88                   dey             ;ff
000FE4  1  28                   plp
000FE5  1  98                   tya
000FE6  1  08 C9 FF D0          tst_a $ff,minus
000FEA  1  FE 68 48 C9  
000FEE  1  B0 D0 FE 28  
000FF2  1               
000FF2  1  A9 FF                load_flag $ff
000FF4  1  48                   pha
000FF5  1  A2 FF                ldx #$ff        ;ff
000FF7  1  8A                   txa
000FF8  1  28                   plp
000FF9  1  A8                   tay
000FFA  1  08 C0 FF D0          tst_y $ff,$ff-zero
000FFE  1  FE 68 48 C9  
001002  1  FD D0 FE 28  
001006  1  08                   php
001007  1  E8                   inx             ;00
001008  1  8A                   txa
001009  1  28                   plp
00100A  1  A8                   tay
00100B  1  08 C0 00 D0          tst_y 0,$ff-minus
00100F  1  FE 68 48 C9  
001013  1  7F D0 FE 28  
001017  1  08                   php
001018  1  E8                   inx             ;01
001019  1  8A                   txa
00101A  1  28                   plp
00101B  1  A8                   tay
00101C  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
001020  1  FE 68 48 C9  
001024  1  7D D0 FE 28  
001028  1  A9 00                load_flag 0
00102A  1  48                   pha
00102B  1  A9 00                lda #0
00102D  1  8A                   txa
00102E  1  28                   plp
00102F  1  A8                   tay
001030  1  08 C0 01 D0          tst_y 1,0
001034  1  FE 68 48 C9  
001038  1  30 D0 FE 28  
00103C  1  08                   php
00103D  1  CA                   dex             ;00
00103E  1  8A                   txa
00103F  1  28                   plp
001040  1  A8                   tay
001041  1  08 C0 00 D0          tst_y 0,zero
001045  1  FE 68 48 C9  
001049  1  32 D0 FE 28  
00104D  1  08                   php
00104E  1  CA                   dex             ;ff
00104F  1  8A                   txa
001050  1  28                   plp
001051  1  A8                   tay
001052  1  08 C0 FF D0          tst_y $ff,minus
001056  1  FE 68 48 C9  
00105A  1  B0 D0 FE 28  
00105E  1               
00105E  1               
00105E  1  A9 FF                load_flag $ff
001060  1  48                   pha
001061  1  A0 FF                ldy #$ff        ;ff
001063  1  98                   tya
001064  1  28                   plp
001065  1  AA                   tax
001066  1  08 E0 FF D0          tst_x $ff,$ff-zero
00106A  1  FE 68 48 C9  
00106E  1  FD D0 FE 28  
001072  1  08                   php
001073  1  C8                   iny             ;00
001074  1  98                   tya
001075  1  28                   plp
001076  1  AA                   tax
001077  1  08 E0 00 D0          tst_x 0,$ff-minus
00107B  1  FE 68 48 C9  
00107F  1  7F D0 FE 28  
001083  1  08                   php
001084  1  C8                   iny             ;01
001085  1  98                   tya
001086  1  28                   plp
001087  1  AA                   tax
001088  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
00108C  1  FE 68 48 C9  
001090  1  7D D0 FE 28  
001094  1  A9 00                load_flag 0
001096  1  48                   pha
001097  1  A9 00                lda #0          ;preset status
001099  1  98                   tya
00109A  1  28                   plp
00109B  1  AA                   tax
00109C  1  08 E0 01 D0          tst_x 1,0
0010A0  1  FE 68 48 C9  
0010A4  1  30 D0 FE 28  
0010A8  1  08                   php
0010A9  1  88                   dey             ;00
0010AA  1  98                   tya
0010AB  1  28                   plp
0010AC  1  AA                   tax
0010AD  1  08 E0 00 D0          tst_x 0,zero
0010B1  1  FE 68 48 C9  
0010B5  1  32 D0 FE 28  
0010B9  1  08                   php
0010BA  1  88                   dey             ;ff
0010BB  1  98                   tya
0010BC  1  28                   plp
0010BD  1  AA                   tax
0010BE  1  08 E0 FF D0          tst_x $ff,minus
0010C2  1  FE 68 48 C9  
0010C6  1  B0 D0 FE 28  
0010CA  1  AD 00 02 C9          next_test
0010CE  1  0D D0 FE A9  
0010D2  1  0E 8D 00 02  
001113  1               
001113  1               ;TSX sets NZ - TXS does not
001113  1               ;  This section also tests for proper stack wrap around.
001113  1  A2 01                ldx #1          ;01
001115  1  A9 FF 48 28          set_stat $ff
001119  1  9A                   txs
00111A  1  08                   php
00111B  1  AD 01 01             lda $101
00111E  1  C9 FF                cmp_flag $ff
001120  1  D0 FE                trap_ne
001122  1  A9 00 48 28          set_stat 0
001126  1  9A                   txs
001127  1  08                   php
001128  1  AD 01 01             lda $101
00112B  1  C9 30                cmp_flag 0
00112D  1  D0 FE                trap_ne
00112F  1  CA                   dex             ;00
001130  1  A9 FF 48 28          set_stat $ff
001134  1  9A                   txs
001135  1  08                   php
001136  1  AD 00 01             lda $100
001139  1  C9 FF                cmp_flag $ff
00113B  1  D0 FE                trap_ne
00113D  1  A9 00 48 28          set_stat 0
001141  1  9A                   txs
001142  1  08                   php
001143  1  AD 00 01             lda $100
001146  1  C9 30                cmp_flag 0
001148  1  D0 FE                trap_ne
00114A  1  CA                   dex             ;ff
00114B  1  A9 FF 48 28          set_stat $ff
00114F  1  9A                   txs
001150  1  08                   php
001151  1  AD FF 01             lda $1ff
001154  1  C9 FF                cmp_flag $ff
001156  1  D0 FE                trap_ne
001158  1  A9 00 48 28          set_stat 0
00115C  1  9A                   txs
00115D  1  08                   php
00115E  1  AD FF 01             lda $1ff
001161  1  C9 30                cmp_flag 0
001163  1               
001163  1  A2 01                ldx #1
001165  1  9A                   txs             ;sp=01
001166  1  A9 FF 48 28          set_stat $ff
00116A  1  BA                   tsx             ;clears Z, N
00116B  1  08                   php             ;sp=00
00116C  1  E0 01                cpx #1
00116E  1  D0 FE                trap_ne
001170  1  AD 01 01             lda $101
001173  1  C9 7D                cmp_flag $ff-minus-zero
001175  1  D0 FE                trap_ne
001177  1  A9 FF 48 28          set_stat $ff
00117B  1  BA                   tsx             ;clears N, sets Z
00117C  1  08                   php             ;sp=ff
00117D  1  E0 00                cpx #0
00117F  1  D0 FE                trap_ne
001181  1  AD 00 01             lda $100
001184  1  C9 7F                cmp_flag $ff-minus
001186  1  D0 FE                trap_ne
001188  1  A9 FF 48 28          set_stat $ff
00118C  1  BA                   tsx             ;clears N, sets Z
00118D  1  08                   php             ;sp=fe
00118E  1  E0 FF                cpx #$ff
001190  1  D0 FE                trap_ne
001192  1  AD FF 01             lda $1ff
001195  1  C9 FD                cmp_flag $ff-zero
001197  1  D0 FE                trap_ne
001199  1               
001199  1  A2 01                ldx #1
00119B  1  9A                   txs             ;sp=01
00119C  1  A9 00 48 28          set_stat 0
0011A0  1  BA                   tsx             ;clears Z, N
0011A1  1  08                   php             ;sp=00
0011A2  1  E0 01                cpx #1
0011A4  1  D0 FE                trap_ne
0011A6  1  AD 01 01             lda $101
0011A9  1  C9 30                cmp_flag 0
0011AB  1  D0 FE                trap_ne
0011AD  1  A9 00 48 28          set_stat 0
0011B1  1  BA                   tsx             ;clears N, sets Z
0011B2  1  08                   php             ;sp=ff
0011B3  1  E0 00                cpx #0
0011B5  1  D0 FE                trap_ne
0011B7  1  AD 00 01             lda $100
0011BA  1  C9 32                cmp_flag zero
0011BC  1  D0 FE                trap_ne
0011BE  1  A9 00 48 28          set_stat 0
0011C2  1  BA                   tsx             ;clears N, sets Z
0011C3  1  08                   php             ;sp=fe
0011C4  1  E0 FF                cpx #$ff
0011C6  1  D0 FE                trap_ne
0011C8  1  AD FF 01             lda $1ff
0011CB  1  C9 B0                cmp_flag minus
0011CD  1  D0 FE                trap_ne
0011CF  1  68                   pla             ;sp=ff
0011D0  1  AD 00 02 C9          next_test
0011D4  1  0E D0 FE A9  
0011D8  1  0F 8D 00 02  
001219  1               
001219  1               ; testing index register load & store LDY LDX STY STX all addressing modes
001219  1               ; LDX / STX - zp,y / abs,y
001219  1  A0 03                ldy #3
00121B  1               tldx:
00121B  1  A9 00 48 28          set_stat 0
00121F  1  B6 13                ldx zp1,y
001221  1  08                   php         ;test stores do not alter flags
001222  1  8A                   txa
001223  1  49 C3                eor #$c3
001225  1  28                   plp
001226  1  99 03 02             sta abst,y
001229  1  08                   php         ;flags after load/store sequence
00122A  1  49 C3                eor #$c3
00122C  1  D9 17 02             cmp abs1,y  ;test result
00122F  1  D0 FE                trap_ne
001231  1  68                   pla         ;load status
001232  1  49 30                eor_flag 0
001234  1  D9 1C 02             cmp fLDx,y  ;test flags
001237  1  D0 FE                trap_ne
001239  1  88                   dey
00123A  1  10 DF                bpl tldx
00123C  1               
00123C  1  A0 03                ldy #3
00123E  1               tldx1:
00123E  1  A9 FF 48 28          set_stat $ff
001242  1  B6 13                ldx zp1,y
001244  1  08                   php         ;test stores do not alter flags
001245  1  8A                   txa
001246  1  49 C3                eor #$c3
001248  1  28                   plp
001249  1  99 03 02             sta abst,y
00124C  1  08                   php         ;flags after load/store sequence
00124D  1  49 C3                eor #$c3
00124F  1  D9 17 02             cmp abs1,y  ;test result
001252  1  D0 FE                trap_ne
001254  1  68                   pla         ;load status
001255  1  49 7D                eor_flag <~fnz ;mask bits not altered
001257  1  D9 1C 02             cmp fLDx,y  ;test flags
00125A  1  D0 FE                trap_ne
00125C  1  88                   dey
00125D  1  10 DF                bpl tldx1
00125F  1               
00125F  1  A0 03                ldy #3
001261  1               tldx2:
001261  1  A9 00 48 28          set_stat 0
001265  1  BE 17 02             ldx abs1,y
001268  1  08                   php         ;test stores do not alter flags
001269  1  8A                   txa
00126A  1  49 C3                eor #$c3
00126C  1  AA                   tax
00126D  1  28                   plp
00126E  1  96 0C                stx zpt,y
001270  1  08                   php         ;flags after load/store sequence
001271  1  49 C3                eor #$c3
001273  1  D9 13 00             cmp zp1,y   ;test result
001276  1  D0 FE                trap_ne
001278  1  68                   pla         ;load status
001279  1  49 30                eor_flag 0
00127B  1  D9 1C 02             cmp fLDx,y  ;test flags
00127E  1  D0 FE                trap_ne
001280  1  88                   dey
001281  1  10 DE                bpl tldx2
001283  1               
001283  1  A0 03                ldy #3
001285  1               tldx3:
001285  1  A9 FF 48 28          set_stat $ff
001289  1  BE 17 02             ldx abs1,y
00128C  1  08                   php         ;test stores do not alter flags
00128D  1  8A                   txa
00128E  1  49 C3                eor #$c3
001290  1  AA                   tax
001291  1  28                   plp
001292  1  96 0C                stx zpt,y
001294  1  08                   php         ;flags after load/store sequence
001295  1  49 C3                eor #$c3
001297  1  D9 13 00             cmp zp1,y   ;test result
00129A  1  D0 FE                trap_ne
00129C  1  68                   pla         ;load status
00129D  1  49 7D                eor_flag <~fnz ;mask bits not altered
00129F  1  D9 1C 02             cmp fLDx,y  ;test flags
0012A2  1  D0 FE                trap_ne
0012A4  1  88                   dey
0012A5  1  10 DE                bpl tldx3
0012A7  1               
0012A7  1  A0 03                ldy #3      ;testing store result
0012A9  1  A2 00                ldx #0
0012AB  1  B9 0C 00     tstx:   lda zpt,y
0012AE  1  49 C3                eor #$c3
0012B0  1  D9 13 00             cmp zp1,y
0012B3  1  D0 FE                trap_ne     ;store to zp data
0012B5  1  96 0C                stx zpt,y   ;clear
0012B7  1  B9 03 02             lda abst,y
0012BA  1  49 C3                eor #$c3
0012BC  1  D9 17 02             cmp abs1,y
0012BF  1  D0 FE                trap_ne     ;store to abs data
0012C1  1  8A                   txa
0012C2  1  99 03 02             sta abst,y  ;clear
0012C5  1  88                   dey
0012C6  1  10 E3                bpl tstx
0012C8  1  AD 00 02 C9          next_test
0012CC  1  0F D0 FE A9  
0012D0  1  10 8D 00 02  
001311  1               
001311  1               ; indexed wraparound test (only zp should wrap)
001311  1  A0 FD                ldy #3+$fa
001313  1  B6 19        tldx4:  ldx <(zp1-$fa),y   ;wrap on indexed zp
001315  1  8A                   txa
001316  1  99 09 01             sta abst-$fa,y      ;no STX abs,y!
001319  1  88                   dey
00131A  1  C0 FA                cpy #$fa
00131C  1  B0 F5                bcs tldx4
00131E  1  A0 FD                ldy #3+$fa
001320  1  BE 1D 01     tldx5:  ldx abs1-$fa,y      ;no wrap on indexed abs
001323  1  96 12                stx <(zpt-$fa),y
001325  1  88                   dey
001326  1  C0 FA                cpy #$fa
001328  1  B0 F6                bcs tldx5
00132A  1  A0 03                ldy #3      ;testing wraparound result
00132C  1  A2 00                ldx #0
00132E  1  B9 0C 00     tstx1:  lda zpt,y
001331  1  D9 13 00             cmp zp1,y
001334  1  D0 FE                trap_ne     ;store to zp data
001336  1  96 0C                stx zpt,y   ;clear
001338  1  B9 03 02             lda abst,y
00133B  1  D9 17 02             cmp abs1,y
00133E  1  D0 FE                trap_ne     ;store to abs data
001340  1  8A                   txa
001341  1  99 03 02             sta abst,y  ;clear
001344  1  88                   dey
001345  1  10 E7                bpl tstx1
001347  1  AD 00 02 C9          next_test
00134B  1  10 D0 FE A9  
00134F  1  11 8D 00 02  
001390  1               
001390  1               ; LDY / STY - zp,x / abs,x
001390  1  A2 03                ldx #3
001392  1               tldy:
001392  1  A9 00 48 28          set_stat 0
001396  1  B4 13                ldy zp1,x
001398  1  08                   php         ;test stores do not alter flags
001399  1  98                   tya
00139A  1  49 C3                eor #$c3
00139C  1  28                   plp
00139D  1  9D 03 02             sta abst,x
0013A0  1  08                   php         ;flags after load/store sequence
0013A1  1  49 C3                eor #$c3
0013A3  1  DD 17 02             cmp abs1,x  ;test result
0013A6  1  D0 FE                trap_ne
0013A8  1  68                   pla         ;load status
0013A9  1  49 30                eor_flag 0
0013AB  1  DD 1C 02             cmp fLDx,x  ;test flags
0013AE  1  D0 FE                trap_ne
0013B0  1  CA                   dex
0013B1  1  10 DF                bpl tldy
0013B3  1               
0013B3  1  A2 03                ldx #3
0013B5  1               tldy1:
0013B5  1  A9 FF 48 28          set_stat $ff
0013B9  1  B4 13                ldy zp1,x
0013BB  1  08                   php         ;test stores do not alter flags
0013BC  1  98                   tya
0013BD  1  49 C3                eor #$c3
0013BF  1  28                   plp
0013C0  1  9D 03 02             sta abst,x
0013C3  1  08                   php         ;flags after load/store sequence
0013C4  1  49 C3                eor #$c3
0013C6  1  DD 17 02             cmp abs1,x  ;test result
0013C9  1  D0 FE                trap_ne
0013CB  1  68                   pla         ;load status
0013CC  1  49 7D                eor_flag <~fnz ;mask bits not altered
0013CE  1  DD 1C 02             cmp fLDx,x  ;test flags
0013D1  1  D0 FE                trap_ne
0013D3  1  CA                   dex
0013D4  1  10 DF                bpl tldy1
0013D6  1               
0013D6  1  A2 03                ldx #3
0013D8  1               tldy2:
0013D8  1  A9 00 48 28          set_stat 0
0013DC  1  BC 17 02             ldy abs1,x
0013DF  1  08                   php         ;test stores do not alter flags
0013E0  1  98                   tya
0013E1  1  49 C3                eor #$c3
0013E3  1  A8                   tay
0013E4  1  28                   plp
0013E5  1  94 0C                sty zpt,x
0013E7  1  08                   php         ;flags after load/store sequence
0013E8  1  49 C3                eor #$c3
0013EA  1  D5 13                cmp zp1,x   ;test result
0013EC  1  D0 FE                trap_ne
0013EE  1  68                   pla         ;load status
0013EF  1  49 30                eor_flag 0
0013F1  1  DD 1C 02             cmp fLDx,x  ;test flags
0013F4  1  D0 FE                trap_ne
0013F6  1  CA                   dex
0013F7  1  10 DF                bpl tldy2
0013F9  1               
0013F9  1  A2 03                ldx #3
0013FB  1               tldy3:
0013FB  1  A9 FF 48 28          set_stat $ff
0013FF  1  BC 17 02             ldy abs1,x
001402  1  08                   php         ;test stores do not alter flags
001403  1  98                   tya
001404  1  49 C3                eor #$c3
001406  1  A8                   tay
001407  1  28                   plp
001408  1  94 0C                sty zpt,x
00140A  1  08                   php         ;flags after load/store sequence
00140B  1  49 C3                eor #$c3
00140D  1  D5 13                cmp zp1,x   ;test result
00140F  1  D0 FE                trap_ne
001411  1  68                   pla         ;load status
001412  1  49 7D                eor_flag <~fnz ;mask bits not altered
001414  1  DD 1C 02             cmp fLDx,x  ;test flags
001417  1  D0 FE                trap_ne
001419  1  CA                   dex
00141A  1  10 DF                bpl tldy3
00141C  1               
00141C  1  A2 03                ldx #3      ;testing store result
00141E  1  A0 00                ldy #0
001420  1  B5 0C        tsty:   lda zpt,x
001422  1  49 C3                eor #$c3
001424  1  D5 13                cmp zp1,x
001426  1  D0 FE                trap_ne     ;store to zp,x data
001428  1  94 0C                sty zpt,x   ;clear
00142A  1  BD 03 02             lda abst,x
00142D  1  49 C3                eor #$c3
00142F  1  DD 17 02             cmp abs1,x
001432  1  D0 FE                trap_ne     ;store to abs,x data
001434  1  8A                   txa
001435  1  9D 03 02             sta abst,x  ;clear
001438  1  CA                   dex
001439  1  10 E5                bpl tsty
00143B  1  AD 00 02 C9          next_test
00143F  1  11 D0 FE A9  
001443  1  12 8D 00 02  
001484  1               
001484  1               ; indexed wraparound test (only zp should wrap)
001484  1  A2 FD                ldx #3+$fa
001486  1  B4 19        tldy4:  ldy <(zp1-$fa),x   ;wrap on indexed zp
001488  1  98                   tya
001489  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
00148C  1  CA                   dex
00148D  1  E0 FA                cpx #$fa
00148F  1  B0 F5                bcs tldy4
001491  1  A2 FD                ldx #3+$fa
001493  1  BC 1D 01     tldy5:  ldy abs1-$fa,x      ;no wrap on indexed abs
001496  1  94 12                sty <(zpt-$fa),x
001498  1  CA                   dex
001499  1  E0 FA                cpx #$fa
00149B  1  B0 F6                bcs tldy5
00149D  1  A2 03                ldx #3      ;testing wraparound result
00149F  1  A0 00                ldy #0
0014A1  1  B5 0C        tsty1:  lda zpt,x
0014A3  1  D5 13                cmp zp1,x
0014A5  1  D0 FE                trap_ne     ;store to zp,x data
0014A7  1  94 0C                sty zpt,x   ;clear
0014A9  1  BD 03 02             lda abst,x
0014AC  1  DD 17 02             cmp abs1,x
0014AF  1  D0 FE                trap_ne     ;store to abs,x data
0014B1  1  8A                   txa
0014B2  1  9D 03 02             sta abst,x  ;clear
0014B5  1  CA                   dex
0014B6  1  10 E9                bpl tsty1
0014B8  1  AD 00 02 C9          next_test
0014BC  1  12 D0 FE A9  
0014C0  1  13 8D 00 02  
001501  1               
001501  1               ; LDX / STX - zp / abs / #
001501  1  A9 00 48 28          set_stat 0
001505  1  A6 13                ldx zp1
001507  1  08                   php         ;test stores do not alter flags
001508  1  8A                   txa
001509  1  49 C3                eor #$c3
00150B  1  AA                   tax
00150C  1  28                   plp
00150D  1  8E 03 02             stx abst
001510  1  08                   php         ;flags after load/store sequence
001511  1  49 C3                eor #$c3
001513  1  AA                   tax
001514  1  E0 C3                cpx #$c3    ;test result
001516  1  D0 FE                trap_ne
001518  1  68                   pla         ;load status
001519  1  49 30                eor_flag 0
00151B  1  CD 1C 02             cmp fLDx    ;test flags
00151E  1  D0 FE                trap_ne
001520  1  A9 00 48 28          set_stat 0
001524  1  A6 14                ldx zp1+1
001526  1  08                   php         ;test stores do not alter flags
001527  1  8A                   txa
001528  1  49 C3                eor #$c3
00152A  1  AA                   tax
00152B  1  28                   plp
00152C  1  8E 04 02             stx abst+1
00152F  1  08                   php         ;flags after load/store sequence
001530  1  49 C3                eor #$c3
001532  1  AA                   tax
001533  1  E0 82                cpx #$82    ;test result
001535  1  D0 FE                trap_ne
001537  1  68                   pla         ;load status
001538  1  49 30                eor_flag 0
00153A  1  CD 1D 02             cmp fLDx+1  ;test flags
00153D  1  D0 FE                trap_ne
00153F  1  A9 00 48 28          set_stat 0
001543  1  A6 15                ldx zp1+2
001545  1  08                   php         ;test stores do not alter flags
001546  1  8A                   txa
001547  1  49 C3                eor #$c3
001549  1  AA                   tax
00154A  1  28                   plp
00154B  1  8E 05 02             stx abst+2
00154E  1  08                   php         ;flags after load/store sequence
00154F  1  49 C3                eor #$c3
001551  1  AA                   tax
001552  1  E0 41                cpx #$41    ;test result
001554  1  D0 FE                trap_ne
001556  1  68                   pla         ;load status
001557  1  49 30                eor_flag 0
001559  1  CD 1E 02             cmp fLDx+2  ;test flags
00155C  1  D0 FE                trap_ne
00155E  1  A9 00 48 28          set_stat 0
001562  1  A6 16                ldx zp1+3
001564  1  08                   php         ;test stores do not alter flags
001565  1  8A                   txa
001566  1  49 C3                eor #$c3
001568  1  AA                   tax
001569  1  28                   plp
00156A  1  8E 06 02             stx abst+3
00156D  1  08                   php         ;flags after load/store sequence
00156E  1  49 C3                eor #$c3
001570  1  AA                   tax
001571  1  E0 00                cpx #0      ;test result
001573  1  D0 FE                trap_ne
001575  1  68                   pla         ;load status
001576  1  49 30                eor_flag 0
001578  1  CD 1F 02             cmp fLDx+3  ;test flags
00157B  1  D0 FE                trap_ne
00157D  1               
00157D  1  A9 FF 48 28          set_stat $ff
001581  1  A6 13                ldx zp1
001583  1  08                   php         ;test stores do not alter flags
001584  1  8A                   txa
001585  1  49 C3                eor #$c3
001587  1  AA                   tax
001588  1  28                   plp
001589  1  8E 03 02             stx abst
00158C  1  08                   php         ;flags after load/store sequence
00158D  1  49 C3                eor #$c3
00158F  1  AA                   tax
001590  1  E0 C3                cpx #$c3    ;test result
001592  1  D0 FE                trap_ne     ;
001594  1  68                   pla         ;load status
001595  1  49 7D                eor_flag <~fnz ;mask bits not altered
001597  1  CD 1C 02             cmp fLDx    ;test flags
00159A  1  D0 FE                trap_ne
00159C  1  A9 FF 48 28          set_stat $ff
0015A0  1  A6 14                ldx zp1+1
0015A2  1  08                   php         ;test stores do not alter flags
0015A3  1  8A                   txa
0015A4  1  49 C3                eor #$c3
0015A6  1  AA                   tax
0015A7  1  28                   plp
0015A8  1  8E 04 02             stx abst+1
0015AB  1  08                   php         ;flags after load/store sequence
0015AC  1  49 C3                eor #$c3
0015AE  1  AA                   tax
0015AF  1  E0 82                cpx #$82    ;test result
0015B1  1  D0 FE                trap_ne
0015B3  1  68                   pla         ;load status
0015B4  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015B6  1  CD 1D 02             cmp fLDx+1  ;test flags
0015B9  1  D0 FE                trap_ne
0015BB  1  A9 FF 48 28          set_stat $ff
0015BF  1  A6 15                ldx zp1+2
0015C1  1  08                   php         ;test stores do not alter flags
0015C2  1  8A                   txa
0015C3  1  49 C3                eor #$c3
0015C5  1  AA                   tax
0015C6  1  28                   plp
0015C7  1  8E 05 02             stx abst+2
0015CA  1  08                   php         ;flags after load/store sequence
0015CB  1  49 C3                eor #$c3
0015CD  1  AA                   tax
0015CE  1  E0 41                cpx #$41    ;test result
0015D0  1  D0 FE                trap_ne     ;
0015D2  1  68                   pla         ;load status
0015D3  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015D5  1  CD 1E 02             cmp fLDx+2  ;test flags
0015D8  1  D0 FE                trap_ne
0015DA  1  A9 FF 48 28          set_stat $ff
0015DE  1  A6 16                ldx zp1+3
0015E0  1  08                   php         ;test stores do not alter flags
0015E1  1  8A                   txa
0015E2  1  49 C3                eor #$c3
0015E4  1  AA                   tax
0015E5  1  28                   plp
0015E6  1  8E 06 02             stx abst+3
0015E9  1  08                   php         ;flags after load/store sequence
0015EA  1  49 C3                eor #$c3
0015EC  1  AA                   tax
0015ED  1  E0 00                cpx #0      ;test result
0015EF  1  D0 FE                trap_ne
0015F1  1  68                   pla         ;load status
0015F2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015F4  1  CD 1F 02             cmp fLDx+3  ;test flags
0015F7  1  D0 FE                trap_ne
0015F9  1               
0015F9  1  A9 00 48 28          set_stat 0
0015FD  1  AE 17 02             ldx abs1
001600  1  08                   php         ;test stores do not alter flags
001601  1  8A                   txa
001602  1  49 C3                eor #$c3
001604  1  AA                   tax
001605  1  28                   plp
001606  1  86 0C                stx zpt
001608  1  08                   php         ;flags after load/store sequence
001609  1  49 C3                eor #$c3
00160B  1  C5 13                cmp zp1     ;test result
00160D  1  D0 FE                trap_ne
00160F  1  68                   pla         ;load status
001610  1  49 30                eor_flag 0
001612  1  CD 1C 02             cmp fLDx    ;test flags
001615  1  D0 FE                trap_ne
001617  1  A9 00 48 28          set_stat 0
00161B  1  AE 18 02             ldx abs1+1
00161E  1  08                   php         ;test stores do not alter flags
00161F  1  8A                   txa
001620  1  49 C3                eor #$c3
001622  1  AA                   tax
001623  1  28                   plp
001624  1  86 0D                stx zpt+1
001626  1  08                   php         ;flags after load/store sequence
001627  1  49 C3                eor #$c3
001629  1  C5 14                cmp zp1+1   ;test result
00162B  1  D0 FE                trap_ne
00162D  1  68                   pla         ;load status
00162E  1  49 30                eor_flag 0
001630  1  CD 1D 02             cmp fLDx+1  ;test flags
001633  1  D0 FE                trap_ne
001635  1  A9 00 48 28          set_stat 0
001639  1  AE 19 02             ldx abs1+2
00163C  1  08                   php         ;test stores do not alter flags
00163D  1  8A                   txa
00163E  1  49 C3                eor #$c3
001640  1  AA                   tax
001641  1  28                   plp
001642  1  86 0E                stx zpt+2
001644  1  08                   php         ;flags after load/store sequence
001645  1  49 C3                eor #$c3
001647  1  C5 15                cmp zp1+2   ;test result
001649  1  D0 FE                trap_ne
00164B  1  68                   pla         ;load status
00164C  1  49 30                eor_flag 0
00164E  1  CD 1E 02             cmp fLDx+2  ;test flags
001651  1  D0 FE                trap_ne
001653  1  A9 00 48 28          set_stat 0
001657  1  AE 1A 02             ldx abs1+3
00165A  1  08                   php         ;test stores do not alter flags
00165B  1  8A                   txa
00165C  1  49 C3                eor #$c3
00165E  1  AA                   tax
00165F  1  28                   plp
001660  1  86 0F                stx zpt+3
001662  1  08                   php         ;flags after load/store sequence
001663  1  49 C3                eor #$c3
001665  1  C5 16                cmp zp1+3   ;test result
001667  1  D0 FE                trap_ne
001669  1  68                   pla         ;load status
00166A  1  49 30                eor_flag 0
00166C  1  CD 1F 02             cmp fLDx+3  ;test flags
00166F  1  D0 FE                trap_ne
001671  1               
001671  1  A9 FF 48 28          set_stat $ff
001675  1  AE 17 02             ldx abs1
001678  1  08                   php         ;test stores do not alter flags
001679  1  8A                   txa
00167A  1  49 C3                eor #$c3
00167C  1  AA                   tax
00167D  1  28                   plp
00167E  1  86 0C                stx zpt
001680  1  08                   php         ;flags after load/store sequence
001681  1  49 C3                eor #$c3
001683  1  AA                   tax
001684  1  E4 13                cpx zp1     ;test result
001686  1  D0 FE                trap_ne
001688  1  68                   pla         ;load status
001689  1  49 7D                eor_flag <~fnz ;mask bits not altered
00168B  1  CD 1C 02             cmp fLDx    ;test flags
00168E  1  D0 FE                trap_ne
001690  1  A9 FF 48 28          set_stat $ff
001694  1  AE 18 02             ldx abs1+1
001697  1  08                   php         ;test stores do not alter flags
001698  1  8A                   txa
001699  1  49 C3                eor #$c3
00169B  1  AA                   tax
00169C  1  28                   plp
00169D  1  86 0D                stx zpt+1
00169F  1  08                   php         ;flags after load/store sequence
0016A0  1  49 C3                eor #$c3
0016A2  1  AA                   tax
0016A3  1  E4 14                cpx zp1+1   ;test result
0016A5  1  D0 FE                trap_ne
0016A7  1  68                   pla         ;load status
0016A8  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016AA  1  CD 1D 02             cmp fLDx+1  ;test flags
0016AD  1  D0 FE                trap_ne
0016AF  1  A9 FF 48 28          set_stat $ff
0016B3  1  AE 19 02             ldx abs1+2
0016B6  1  08                   php         ;test stores do not alter flags
0016B7  1  8A                   txa
0016B8  1  49 C3                eor #$c3
0016BA  1  AA                   tax
0016BB  1  28                   plp
0016BC  1  86 0E                stx zpt+2
0016BE  1  08                   php         ;flags after load/store sequence
0016BF  1  49 C3                eor #$c3
0016C1  1  AA                   tax
0016C2  1  E4 15                cpx zp1+2   ;test result
0016C4  1  D0 FE                trap_ne
0016C6  1  68                   pla         ;load status
0016C7  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016C9  1  CD 1E 02             cmp fLDx+2  ;test flags
0016CC  1  D0 FE                trap_ne
0016CE  1  A9 FF 48 28          set_stat $ff
0016D2  1  AE 1A 02             ldx abs1+3
0016D5  1  08                   php         ;test stores do not alter flags
0016D6  1  8A                   txa
0016D7  1  49 C3                eor #$c3
0016D9  1  AA                   tax
0016DA  1  28                   plp
0016DB  1  86 0F                stx zpt+3
0016DD  1  08                   php         ;flags after load/store sequence
0016DE  1  49 C3                eor #$c3
0016E0  1  AA                   tax
0016E1  1  E4 16                cpx zp1+3   ;test result
0016E3  1  D0 FE                trap_ne
0016E5  1  68                   pla         ;load status
0016E6  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016E8  1  CD 1F 02             cmp fLDx+3  ;test flags
0016EB  1  D0 FE                trap_ne
0016ED  1               
0016ED  1  A9 00 48 28          set_stat 0
0016F1  1  A2 C3                ldx #$c3
0016F3  1  08                   php
0016F4  1  EC 17 02             cpx abs1    ;test result
0016F7  1  D0 FE                trap_ne
0016F9  1  68                   pla         ;load status
0016FA  1  49 30                eor_flag 0
0016FC  1  CD 1C 02             cmp fLDx    ;test flags
0016FF  1  D0 FE                trap_ne
001701  1  A9 00 48 28          set_stat 0
001705  1  A2 82                ldx #$82
001707  1  08                   php
001708  1  EC 18 02             cpx abs1+1  ;test result
00170B  1  D0 FE                trap_ne
00170D  1  68                   pla         ;load status
00170E  1  49 30                eor_flag 0
001710  1  CD 1D 02             cmp fLDx+1  ;test flags
001713  1  D0 FE                trap_ne
001715  1  A9 00 48 28          set_stat 0
001719  1  A2 41                ldx #$41
00171B  1  08                   php
00171C  1  EC 19 02             cpx abs1+2  ;test result
00171F  1  D0 FE                trap_ne
001721  1  68                   pla         ;load status
001722  1  49 30                eor_flag 0
001724  1  CD 1E 02             cmp fLDx+2  ;test flags
001727  1  D0 FE                trap_ne
001729  1  A9 00 48 28          set_stat 0
00172D  1  A2 00                ldx #0
00172F  1  08                   php
001730  1  EC 1A 02             cpx abs1+3  ;test result
001733  1  D0 FE                trap_ne
001735  1  68                   pla         ;load status
001736  1  49 30                eor_flag 0
001738  1  CD 1F 02             cmp fLDx+3  ;test flags
00173B  1  D0 FE                trap_ne
00173D  1               
00173D  1  A9 FF 48 28          set_stat $ff
001741  1  A2 C3                ldx #$c3
001743  1  08                   php
001744  1  EC 17 02             cpx abs1    ;test result
001747  1  D0 FE                trap_ne
001749  1  68                   pla         ;load status
00174A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00174C  1  CD 1C 02             cmp fLDx    ;test flags
00174F  1  D0 FE                trap_ne
001751  1  A9 FF 48 28          set_stat $ff
001755  1  A2 82                ldx #$82
001757  1  08                   php
001758  1  EC 18 02             cpx abs1+1  ;test result
00175B  1  D0 FE                trap_ne
00175D  1  68                   pla         ;load status
00175E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001760  1  CD 1D 02             cmp fLDx+1  ;test flags
001763  1  D0 FE                trap_ne
001765  1  A9 FF 48 28          set_stat $ff
001769  1  A2 41                ldx #$41
00176B  1  08                   php
00176C  1  EC 19 02             cpx abs1+2  ;test result
00176F  1  D0 FE                trap_ne
001771  1  68                   pla         ;load status
001772  1  49 7D                eor_flag <~fnz ;mask bits not altered
001774  1  CD 1E 02             cmp fLDx+2  ;test flags
001777  1  D0 FE                trap_ne
001779  1  A9 FF 48 28          set_stat $ff
00177D  1  A2 00                ldx #0
00177F  1  08                   php
001780  1  EC 1A 02             cpx abs1+3  ;test result
001783  1  D0 FE                trap_ne
001785  1  68                   pla         ;load status
001786  1  49 7D                eor_flag <~fnz ;mask bits not altered
001788  1  CD 1F 02             cmp fLDx+3  ;test flags
00178B  1  D0 FE                trap_ne
00178D  1               
00178D  1  A2 00                ldx #0
00178F  1  A5 0C                lda zpt
001791  1  49 C3                eor #$c3
001793  1  C5 13                cmp zp1
001795  1  D0 FE                trap_ne     ;store to zp data
001797  1  86 0C                stx zpt     ;clear
001799  1  AD 03 02             lda abst
00179C  1  49 C3                eor #$c3
00179E  1  CD 17 02             cmp abs1
0017A1  1  D0 FE                trap_ne     ;store to abs data
0017A3  1  8E 03 02             stx abst    ;clear
0017A6  1  A5 0D                lda zpt+1
0017A8  1  49 C3                eor #$c3
0017AA  1  C5 14                cmp zp1+1
0017AC  1  D0 FE                trap_ne     ;store to zp data
0017AE  1  86 0D                stx zpt+1   ;clear
0017B0  1  AD 04 02             lda abst+1
0017B3  1  49 C3                eor #$c3
0017B5  1  CD 18 02             cmp abs1+1
0017B8  1  D0 FE                trap_ne     ;store to abs data
0017BA  1  8E 04 02             stx abst+1  ;clear
0017BD  1  A5 0E                lda zpt+2
0017BF  1  49 C3                eor #$c3
0017C1  1  C5 15                cmp zp1+2
0017C3  1  D0 FE                trap_ne     ;store to zp data
0017C5  1  86 0E                stx zpt+2   ;clear
0017C7  1  AD 05 02             lda abst+2
0017CA  1  49 C3                eor #$c3
0017CC  1  CD 19 02             cmp abs1+2
0017CF  1  D0 FE                trap_ne     ;store to abs data
0017D1  1  8E 05 02             stx abst+2  ;clear
0017D4  1  A5 0F                lda zpt+3
0017D6  1  49 C3                eor #$c3
0017D8  1  C5 16                cmp zp1+3
0017DA  1  D0 FE                trap_ne     ;store to zp data
0017DC  1  86 0F                stx zpt+3   ;clear
0017DE  1  AD 06 02             lda abst+3
0017E1  1  49 C3                eor #$c3
0017E3  1  CD 1A 02             cmp abs1+3
0017E6  1  D0 FE                trap_ne     ;store to abs data
0017E8  1  8E 06 02             stx abst+3  ;clear
0017EB  1  AD 00 02 C9          next_test
0017EF  1  13 D0 FE A9  
0017F3  1  14 8D 00 02  
001834  1               
001834  1               ; LDY / STY - zp / abs / #
001834  1  A9 00 48 28          set_stat 0
001838  1  A4 13                ldy zp1
00183A  1  08                   php         ;test stores do not alter flags
00183B  1  98                   tya
00183C  1  49 C3                eor #$c3
00183E  1  A8                   tay
00183F  1  28                   plp
001840  1  8C 03 02             sty abst
001843  1  08                   php         ;flags after load/store sequence
001844  1  49 C3                eor #$c3
001846  1  A8                   tay
001847  1  C0 C3                cpy #$c3    ;test result
001849  1  D0 FE                trap_ne
00184B  1  68                   pla         ;load status
00184C  1  49 30                eor_flag 0
00184E  1  CD 1C 02             cmp fLDx    ;test flags
001851  1  D0 FE                trap_ne
001853  1  A9 00 48 28          set_stat 0
001857  1  A4 14                ldy zp1+1
001859  1  08                   php         ;test stores do not alter flags
00185A  1  98                   tya
00185B  1  49 C3                eor #$c3
00185D  1  A8                   tay
00185E  1  28                   plp
00185F  1  8C 04 02             sty abst+1
001862  1  08                   php         ;flags after load/store sequence
001863  1  49 C3                eor #$c3
001865  1  A8                   tay
001866  1  C0 82                cpy #$82    ;test result
001868  1  D0 FE                trap_ne
00186A  1  68                   pla         ;load status
00186B  1  49 30                eor_flag 0
00186D  1  CD 1D 02             cmp fLDx+1  ;test flags
001870  1  D0 FE                trap_ne
001872  1  A9 00 48 28          set_stat 0
001876  1  A4 15                ldy zp1+2
001878  1  08                   php         ;test stores do not alter flags
001879  1  98                   tya
00187A  1  49 C3                eor #$c3
00187C  1  A8                   tay
00187D  1  28                   plp
00187E  1  8C 05 02             sty abst+2
001881  1  08                   php         ;flags after load/store sequence
001882  1  49 C3                eor #$c3
001884  1  A8                   tay
001885  1  C0 41                cpy #$41    ;test result
001887  1  D0 FE                trap_ne
001889  1  68                   pla         ;load status
00188A  1  49 30                eor_flag 0
00188C  1  CD 1E 02             cmp fLDx+2  ;test flags
00188F  1  D0 FE                trap_ne
001891  1  A9 00 48 28          set_stat 0
001895  1  A4 16                ldy zp1+3
001897  1  08                   php         ;test stores do not alter flags
001898  1  98                   tya
001899  1  49 C3                eor #$c3
00189B  1  A8                   tay
00189C  1  28                   plp
00189D  1  8C 06 02             sty abst+3
0018A0  1  08                   php         ;flags after load/store sequence
0018A1  1  49 C3                eor #$c3
0018A3  1  A8                   tay
0018A4  1  C0 00                cpy #0      ;test result
0018A6  1  D0 FE                trap_ne
0018A8  1  68                   pla         ;load status
0018A9  1  49 30                eor_flag 0
0018AB  1  CD 1F 02             cmp fLDx+3  ;test flags
0018AE  1  D0 FE                trap_ne
0018B0  1               
0018B0  1  A9 FF 48 28          set_stat $ff
0018B4  1  A4 13                ldy zp1
0018B6  1  08                   php         ;test stores do not alter flags
0018B7  1  98                   tya
0018B8  1  49 C3                eor #$c3
0018BA  1  A8                   tay
0018BB  1  28                   plp
0018BC  1  8C 03 02             sty abst
0018BF  1  08                   php         ;flags after load/store sequence
0018C0  1  49 C3                eor #$c3
0018C2  1  A8                   tay
0018C3  1  C0 C3                cpy #$c3    ;test result
0018C5  1  D0 FE                trap_ne
0018C7  1  68                   pla         ;load status
0018C8  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018CA  1  CD 1C 02             cmp fLDx    ;test flags
0018CD  1  D0 FE                trap_ne
0018CF  1  A9 FF 48 28          set_stat $ff
0018D3  1  A4 14                ldy zp1+1
0018D5  1  08                   php         ;test stores do not alter flags
0018D6  1  98                   tya
0018D7  1  49 C3                eor #$c3
0018D9  1  A8                   tay
0018DA  1  28                   plp
0018DB  1  8C 04 02             sty abst+1
0018DE  1  08                   php         ;flags after load/store sequence
0018DF  1  49 C3                eor #$c3
0018E1  1  A8                   tay
0018E2  1  C0 82                cpy #$82   ;test result
0018E4  1  D0 FE                trap_ne
0018E6  1  68                   pla         ;load status
0018E7  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018E9  1  CD 1D 02             cmp fLDx+1  ;test flags
0018EC  1  D0 FE                trap_ne
0018EE  1  A9 FF 48 28          set_stat $ff
0018F2  1  A4 15                ldy zp1+2
0018F4  1  08                   php         ;test stores do not alter flags
0018F5  1  98                   tya
0018F6  1  49 C3                eor #$c3
0018F8  1  A8                   tay
0018F9  1  28                   plp
0018FA  1  8C 05 02             sty abst+2
0018FD  1  08                   php         ;flags after load/store sequence
0018FE  1  49 C3                eor #$c3
001900  1  A8                   tay
001901  1  C0 41                cpy #$41    ;test result
001903  1  D0 FE                trap_ne
001905  1  68                   pla         ;load status
001906  1  49 7D                eor_flag <~fnz ;mask bits not altered
001908  1  CD 1E 02             cmp fLDx+2  ;test flags
00190B  1  D0 FE                trap_ne
00190D  1  A9 FF 48 28          set_stat $ff
001911  1  A4 16                ldy zp1+3
001913  1  08                   php         ;test stores do not alter flags
001914  1  98                   tya
001915  1  49 C3                eor #$c3
001917  1  A8                   tay
001918  1  28                   plp
001919  1  8C 06 02             sty abst+3
00191C  1  08                   php         ;flags after load/store sequence
00191D  1  49 C3                eor #$c3
00191F  1  A8                   tay
001920  1  C0 00                cpy #0      ;test result
001922  1  D0 FE                trap_ne
001924  1  68                   pla         ;load status
001925  1  49 7D                eor_flag <~fnz ;mask bits not altered
001927  1  CD 1F 02             cmp fLDx+3  ;test flags
00192A  1  D0 FE                trap_ne
00192C  1               
00192C  1  A9 00 48 28          set_stat 0
001930  1  AC 17 02             ldy abs1
001933  1  08                   php         ;test stores do not alter flags
001934  1  98                   tya
001935  1  49 C3                eor #$c3
001937  1  A8                   tay
001938  1  28                   plp
001939  1  84 0C                sty zpt
00193B  1  08                   php         ;flags after load/store sequence
00193C  1  49 C3                eor #$c3
00193E  1  A8                   tay
00193F  1  C4 13                cpy zp1     ;test result
001941  1  D0 FE                trap_ne
001943  1  68                   pla         ;load status
001944  1  49 30                eor_flag 0
001946  1  CD 1C 02             cmp fLDx    ;test flags
001949  1  D0 FE                trap_ne
00194B  1  A9 00 48 28          set_stat 0
00194F  1  AC 18 02             ldy abs1+1
001952  1  08                   php         ;test stores do not alter flags
001953  1  98                   tya
001954  1  49 C3                eor #$c3
001956  1  A8                   tay
001957  1  28                   plp
001958  1  84 0D                sty zpt+1
00195A  1  08                   php         ;flags after load/store sequence
00195B  1  49 C3                eor #$c3
00195D  1  A8                   tay
00195E  1  C4 14                cpy zp1+1   ;test result
001960  1  D0 FE                trap_ne
001962  1  68                   pla         ;load status
001963  1  49 30                eor_flag 0
001965  1  CD 1D 02             cmp fLDx+1  ;test flags
001968  1  D0 FE                trap_ne
00196A  1  A9 00 48 28          set_stat 0
00196E  1  AC 19 02             ldy abs1+2
001971  1  08                   php         ;test stores do not alter flags
001972  1  98                   tya
001973  1  49 C3                eor #$c3
001975  1  A8                   tay
001976  1  28                   plp
001977  1  84 0E                sty zpt+2
001979  1  08                   php         ;flags after load/store sequence
00197A  1  49 C3                eor #$c3
00197C  1  A8                   tay
00197D  1  C4 15                cpy zp1+2   ;test result
00197F  1  D0 FE                trap_ne
001981  1  68                   pla         ;load status
001982  1  49 30                eor_flag 0
001984  1  CD 1E 02             cmp fLDx+2  ;test flags
001987  1  D0 FE                trap_ne
001989  1  A9 00 48 28          set_stat 0
00198D  1  AC 1A 02             ldy abs1+3
001990  1  08                   php         ;test stores do not alter flags
001991  1  98                   tya
001992  1  49 C3                eor #$c3
001994  1  A8                   tay
001995  1  28                   plp
001996  1  84 0F                sty zpt+3
001998  1  08                   php         ;flags after load/store sequence
001999  1  49 C3                eor #$c3
00199B  1  A8                   tay
00199C  1  C4 16                cpy zp1+3   ;test result
00199E  1  D0 FE                trap_ne
0019A0  1  68                   pla         ;load status
0019A1  1  49 30                eor_flag 0
0019A3  1  CD 1F 02             cmp fLDx+3  ;test flags
0019A6  1  D0 FE                trap_ne
0019A8  1               
0019A8  1  A9 FF 48 28          set_stat $ff
0019AC  1  AC 17 02             ldy abs1
0019AF  1  08                   php         ;test stores do not alter flags
0019B0  1  98                   tya
0019B1  1  49 C3                eor #$c3
0019B3  1  A8                   tay
0019B4  1  28                   plp
0019B5  1  84 0C                sty zpt
0019B7  1  08                   php         ;flags after load/store sequence
0019B8  1  49 C3                eor #$c3
0019BA  1  A8                   tay
0019BB  1  C5 13                cmp zp1     ;test result
0019BD  1  D0 FE                trap_ne
0019BF  1  68                   pla         ;load status
0019C0  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019C2  1  CD 1C 02             cmp fLDx    ;test flags
0019C5  1  D0 FE                trap_ne
0019C7  1  A9 FF 48 28          set_stat $ff
0019CB  1  AC 18 02             ldy abs1+1
0019CE  1  08                   php         ;test stores do not alter flags
0019CF  1  98                   tya
0019D0  1  49 C3                eor #$c3
0019D2  1  A8                   tay
0019D3  1  28                   plp
0019D4  1  84 0D                sty zpt+1
0019D6  1  08                   php         ;flags after load/store sequence
0019D7  1  49 C3                eor #$c3
0019D9  1  A8                   tay
0019DA  1  C5 14                cmp zp1+1   ;test result
0019DC  1  D0 FE                trap_ne
0019DE  1  68                   pla         ;load status
0019DF  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019E1  1  CD 1D 02             cmp fLDx+1  ;test flags
0019E4  1  D0 FE                trap_ne
0019E6  1  A9 FF 48 28          set_stat $ff
0019EA  1  AC 19 02             ldy abs1+2
0019ED  1  08                   php         ;test stores do not alter flags
0019EE  1  98                   tya
0019EF  1  49 C3                eor #$c3
0019F1  1  A8                   tay
0019F2  1  28                   plp
0019F3  1  84 0E                sty zpt+2
0019F5  1  08                   php         ;flags after load/store sequence
0019F6  1  49 C3                eor #$c3
0019F8  1  A8                   tay
0019F9  1  C5 15                cmp zp1+2   ;test result
0019FB  1  D0 FE                trap_ne
0019FD  1  68                   pla         ;load status
0019FE  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A00  1  CD 1E 02             cmp fLDx+2  ;test flags
001A03  1  D0 FE                trap_ne
001A05  1  A9 FF 48 28          set_stat $ff
001A09  1  AC 1A 02             ldy abs1+3
001A0C  1  08                   php         ;test stores do not alter flags
001A0D  1  98                   tya
001A0E  1  49 C3                eor #$c3
001A10  1  A8                   tay
001A11  1  28                   plp
001A12  1  84 0F                sty zpt+3
001A14  1  08                   php         ;flags after load/store sequence
001A15  1  49 C3                eor #$c3
001A17  1  A8                   tay
001A18  1  C5 16                cmp zp1+3   ;test result
001A1A  1  D0 FE                trap_ne
001A1C  1  68                   pla         ;load status
001A1D  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A1F  1  CD 1F 02             cmp fLDx+3  ;test flags
001A22  1  D0 FE                trap_ne
001A24  1               
001A24  1               
001A24  1  A9 00 48 28          set_stat 0
001A28  1  A0 C3                ldy #$c3
001A2A  1  08                   php
001A2B  1  CC 17 02             cpy abs1    ;test result
001A2E  1  D0 FE                trap_ne
001A30  1  68                   pla         ;load status
001A31  1  49 30                eor_flag 0
001A33  1  CD 1C 02             cmp fLDx    ;test flags
001A36  1  D0 FE                trap_ne
001A38  1  A9 00 48 28          set_stat 0
001A3C  1  A0 82                ldy #$82
001A3E  1  08                   php
001A3F  1  CC 18 02             cpy abs1+1  ;test result
001A42  1  D0 FE                trap_ne
001A44  1  68                   pla         ;load status
001A45  1  49 30                eor_flag 0
001A47  1  CD 1D 02             cmp fLDx+1  ;test flags
001A4A  1  D0 FE                trap_ne
001A4C  1  A9 00 48 28          set_stat 0
001A50  1  A0 41                ldy #$41
001A52  1  08                   php
001A53  1  CC 19 02             cpy abs1+2  ;test result
001A56  1  D0 FE                trap_ne
001A58  1  68                   pla         ;load status
001A59  1  49 30                eor_flag 0
001A5B  1  CD 1E 02             cmp fLDx+2  ;test flags
001A5E  1  D0 FE                trap_ne
001A60  1  A9 00 48 28          set_stat 0
001A64  1  A0 00                ldy #0
001A66  1  08                   php
001A67  1  CC 1A 02             cpy abs1+3  ;test result
001A6A  1  D0 FE                trap_ne
001A6C  1  68                   pla         ;load status
001A6D  1  49 30                eor_flag 0
001A6F  1  CD 1F 02             cmp fLDx+3  ;test flags
001A72  1  D0 FE                trap_ne
001A74  1               
001A74  1  A9 FF 48 28          set_stat $ff
001A78  1  A0 C3                ldy #$c3
001A7A  1  08                   php
001A7B  1  CC 17 02             cpy abs1    ;test result
001A7E  1  D0 FE                trap_ne
001A80  1  68                   pla         ;load status
001A81  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A83  1  CD 1C 02             cmp fLDx    ;test flags
001A86  1  D0 FE                trap_ne
001A88  1  A9 FF 48 28          set_stat $ff
001A8C  1  A0 82                ldy #$82
001A8E  1  08                   php
001A8F  1  CC 18 02             cpy abs1+1  ;test result
001A92  1  D0 FE                trap_ne
001A94  1  68                   pla         ;load status
001A95  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A97  1  CD 1D 02             cmp fLDx+1  ;test flags
001A9A  1  D0 FE                trap_ne
001A9C  1  A9 FF 48 28          set_stat $ff
001AA0  1  A0 41                ldy #$41
001AA2  1  08                   php
001AA3  1  CC 19 02             cpy abs1+2   ;test result
001AA6  1  D0 FE                trap_ne
001AA8  1  68                   pla         ;load status
001AA9  1  49 7D                eor_flag <~fnz ;mask bits not altered
001AAB  1  CD 1E 02             cmp fLDx+2  ;test flags
001AAE  1  D0 FE                trap_ne
001AB0  1  A9 FF 48 28          set_stat $ff
001AB4  1  A0 00                ldy #0
001AB6  1  08                   php
001AB7  1  CC 1A 02             cpy abs1+3  ;test result
001ABA  1  D0 FE                trap_ne
001ABC  1  68                   pla         ;load status
001ABD  1  49 7D                eor_flag <~fnz ;mask bits not altered
001ABF  1  CD 1F 02             cmp fLDx+3  ;test flags
001AC2  1  D0 FE                trap_ne
001AC4  1               
001AC4  1  A0 00                ldy #0
001AC6  1  A5 0C                lda zpt
001AC8  1  49 C3                eor #$c3
001ACA  1  C5 13                cmp zp1
001ACC  1  D0 FE                trap_ne     ;store to zp   data
001ACE  1  84 0C                sty zpt     ;clear
001AD0  1  AD 03 02             lda abst
001AD3  1  49 C3                eor #$c3
001AD5  1  CD 17 02             cmp abs1
001AD8  1  D0 FE                trap_ne     ;store to abs   data
001ADA  1  8C 03 02             sty abst    ;clear
001ADD  1  A5 0D                lda zpt+1
001ADF  1  49 C3                eor #$c3
001AE1  1  C5 14                cmp zp1+1
001AE3  1  D0 FE                trap_ne     ;store to zp+1 data
001AE5  1  84 0D                sty zpt+1   ;clear
001AE7  1  AD 04 02             lda abst+1
001AEA  1  49 C3                eor #$c3
001AEC  1  CD 18 02             cmp abs1+1
001AEF  1  D0 FE                trap_ne     ;store to abs+1 data
001AF1  1  8C 04 02             sty abst+1  ;clear
001AF4  1  A5 0E                lda zpt+2
001AF6  1  49 C3                eor #$c3
001AF8  1  C5 15                cmp zp1+2
001AFA  1  D0 FE                trap_ne     ;store to zp+2 data
001AFC  1  84 0E                sty zpt+2   ;clear
001AFE  1  AD 05 02             lda abst+2
001B01  1  49 C3                eor #$c3
001B03  1  CD 19 02             cmp abs1+2
001B06  1  D0 FE                trap_ne     ;store to abs+2 data
001B08  1  8C 05 02             sty abst+2  ;clear
001B0B  1  A5 0F                lda zpt+3
001B0D  1  49 C3                eor #$c3
001B0F  1  C5 16                cmp zp1+3
001B11  1  D0 FE                trap_ne     ;store to zp+3 data
001B13  1  84 0F                sty zpt+3   ;clear
001B15  1  AD 06 02             lda abst+3
001B18  1  49 C3                eor #$c3
001B1A  1  CD 1A 02             cmp abs1+3
001B1D  1  D0 FE                trap_ne     ;store to abs+3 data
001B1F  1  8C 06 02             sty abst+3  ;clear
001B22  1  AD 00 02 C9          next_test
001B26  1  14 D0 FE A9  
001B2A  1  15 8D 00 02  
001B6B  1               
001B6B  1               ; testing load / store accumulator LDA / STA all addressing modes
001B6B  1               ; LDA / STA - zp,x / abs,x
001B6B  1  A2 03                ldx #3
001B6D  1               tldax:
001B6D  1  A9 00 48 28          set_stat 0
001B71  1  B5 13                lda zp1,x
001B73  1  08                   php         ;test stores do not alter flags
001B74  1  49 C3                eor #$c3
001B76  1  28                   plp
001B77  1  9D 03 02             sta abst,x
001B7A  1  08                   php         ;flags after load/store sequence
001B7B  1  49 C3                eor #$c3
001B7D  1  DD 17 02             cmp abs1,x  ;test result
001B80  1  D0 FE                trap_ne
001B82  1  68                   pla         ;load status
001B83  1  49 30                eor_flag 0
001B85  1  DD 1C 02             cmp fLDx,x  ;test flags
001B88  1  D0 FE                trap_ne
001B8A  1  CA                   dex
001B8B  1  10 E0                bpl tldax
001B8D  1               
001B8D  1  A2 03                ldx #3
001B8F  1               tldax1:
001B8F  1  A9 FF 48 28          set_stat $ff
001B93  1  B5 13                lda zp1,x
001B95  1  08                   php         ;test stores do not alter flags
001B96  1  49 C3                eor #$c3
001B98  1  28                   plp
001B99  1  9D 03 02             sta abst,x
001B9C  1  08                   php         ;flags after load/store sequence
001B9D  1  49 C3                eor #$c3
001B9F  1  DD 17 02             cmp abs1,x   ;test result
001BA2  1  D0 FE                trap_ne
001BA4  1  68                   pla         ;load status
001BA5  1  49 7D                eor_flag <~fnz ;mask bits not altered
001BA7  1  DD 1C 02             cmp fLDx,x  ;test flags
001BAA  1  D0 FE                trap_ne
001BAC  1  CA                   dex
001BAD  1  10 E0                bpl tldax1
001BAF  1               
001BAF  1  A2 03                ldx #3
001BB1  1               tldax2:
001BB1  1  A9 00 48 28          set_stat 0
001BB5  1  BD 17 02             lda abs1,x
001BB8  1  08                   php         ;test stores do not alter flags
001BB9  1  49 C3                eor #$c3
001BBB  1  28                   plp
001BBC  1  95 0C                sta zpt,x
001BBE  1  08                   php         ;flags after load/store sequence
001BBF  1  49 C3                eor #$c3
001BC1  1  D5 13                cmp zp1,x   ;test result
001BC3  1  D0 FE                trap_ne
001BC5  1  68                   pla         ;load status
001BC6  1  49 30                eor_flag 0
001BC8  1  DD 1C 02             cmp fLDx,x  ;test flags
001BCB  1  D0 FE                trap_ne
001BCD  1  CA                   dex
001BCE  1  10 E1                bpl tldax2
001BD0  1               
001BD0  1  A2 03                ldx #3
001BD2  1               tldax3:
001BD2  1  A9 FF 48 28          set_stat $ff
001BD6  1  BD 17 02             lda abs1,x
001BD9  1  08                   php         ;test stores do not alter flags
001BDA  1  49 C3                eor #$c3
001BDC  1  28                   plp
001BDD  1  95 0C                sta zpt,x
001BDF  1  08                   php         ;flags after load/store sequence
001BE0  1  49 C3                eor #$c3
001BE2  1  D5 13                cmp zp1,x   ;test result
001BE4  1  D0 FE                trap_ne
001BE6  1  68                   pla         ;load status
001BE7  1  49 7D                eor_flag <~fnz ;mask bits not altered
001BE9  1  DD 1C 02             cmp fLDx,x  ;test flags
001BEC  1  D0 FE                trap_ne
001BEE  1  CA                   dex
001BEF  1  10 E1                bpl tldax3
001BF1  1               
001BF1  1  A2 03                ldx #3      ;testing store result
001BF3  1  A0 00                ldy #0
001BF5  1  B5 0C        tstax:  lda zpt,x
001BF7  1  49 C3                eor #$c3
001BF9  1  D5 13                cmp zp1,x
001BFB  1  D0 FE                trap_ne     ;store to zp,x data
001BFD  1  94 0C                sty zpt,x   ;clear
001BFF  1  BD 03 02             lda abst,x
001C02  1  49 C3                eor #$c3
001C04  1  DD 17 02             cmp abs1,x
001C07  1  D0 FE                trap_ne     ;store to abs,x data
001C09  1  8A                   txa
001C0A  1  9D 03 02             sta abst,x  ;clear
001C0D  1  CA                   dex
001C0E  1  10 E5                bpl tstax
001C10  1  AD 00 02 C9          next_test
001C14  1  15 D0 FE A9  
001C18  1  16 8D 00 02  
001C59  1               
001C59  1               ; LDA / STA - (zp),y / abs,y / (zp,x)
001C59  1  A0 03                ldy #3
001C5B  1               tlday:
001C5B  1  A9 00 48 28          set_stat 0
001C5F  1  B1 24                lda (ind1),y
001C61  1  08                   php         ;test stores do not alter flags
001C62  1  49 C3                eor #$c3
001C64  1  28                   plp
001C65  1  99 03 02             sta abst,y
001C68  1  08                   php         ;flags after load/store sequence
001C69  1  49 C3                eor #$c3
001C6B  1  D9 17 02             cmp abs1,y  ;test result
001C6E  1  D0 FE                trap_ne
001C70  1  68                   pla         ;load status
001C71  1  49 30                eor_flag 0
001C73  1  D9 1C 02             cmp fLDx,y  ;test flags
001C76  1  D0 FE                trap_ne
001C78  1  88                   dey
001C79  1  10 E0                bpl tlday
001C7B  1               
001C7B  1  A0 03                ldy #3
001C7D  1               tlday1:
001C7D  1  A9 FF 48 28          set_stat $ff
001C81  1  B1 24                lda (ind1),y
001C83  1  08                   php         ;test stores do not alter flags
001C84  1  49 C3                eor #$c3
001C86  1  28                   plp
001C87  1  99 03 02             sta abst,y
001C8A  1  08                   php         ;flags after load/store sequence
001C8B  1  49 C3                eor #$c3
001C8D  1  D9 17 02             cmp abs1,y  ;test result
001C90  1  D0 FE                trap_ne
001C92  1  68                   pla         ;load status
001C93  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C95  1  D9 1C 02             cmp fLDx,y  ;test flags
001C98  1  D0 FE                trap_ne
001C9A  1  88                   dey
001C9B  1  10 E0                bpl tlday1
001C9D  1               
001C9D  1  A0 03                ldy #3      ;testing store result
001C9F  1  A2 00                ldx #0
001CA1  1  B9 03 02     tstay:  lda abst,y
001CA4  1  49 C3                eor #$c3
001CA6  1  D9 17 02             cmp abs1,y
001CA9  1  D0 FE                trap_ne     ;store to abs data
001CAB  1  8A                   txa
001CAC  1  99 03 02             sta abst,y  ;clear
001CAF  1  88                   dey
001CB0  1  10 EF                bpl tstay
001CB2  1               
001CB2  1  A0 03                ldy #3
001CB4  1               tlday2:
001CB4  1  A9 00 48 28          set_stat 0
001CB8  1  B9 17 02             lda abs1,y
001CBB  1  08                   php         ;test stores do not alter flags
001CBC  1  49 C3                eor #$c3
001CBE  1  28                   plp
001CBF  1  91 30                sta (indt),y
001CC1  1  08                   php         ;flags after load/store sequence
001CC2  1  49 C3                eor #$c3
001CC4  1  D1 24                cmp (ind1),y    ;test result
001CC6  1  D0 FE                trap_ne
001CC8  1  68                   pla         ;load status
001CC9  1  49 30                eor_flag 0
001CCB  1  D9 1C 02             cmp fLDx,y  ;test flags
001CCE  1  D0 FE                trap_ne
001CD0  1  88                   dey
001CD1  1  10 E1                bpl tlday2
001CD3  1               
001CD3  1  A0 03                ldy #3
001CD5  1               tlday3:
001CD5  1  A9 FF 48 28          set_stat $ff
001CD9  1  B9 17 02             lda abs1,y
001CDC  1  08                   php         ;test stores do not alter flags
001CDD  1  49 C3                eor #$c3
001CDF  1  28                   plp
001CE0  1  91 30                sta (indt),y
001CE2  1  08                   php         ;flags after load/store sequence
001CE3  1  49 C3                eor #$c3
001CE5  1  D1 24                cmp (ind1),y   ;test result
001CE7  1  D0 FE                trap_ne
001CE9  1  68                   pla         ;load status
001CEA  1  49 7D                eor_flag <~fnz ;mask bits not altered
001CEC  1  D9 1C 02             cmp fLDx,y  ;test flags
001CEF  1  D0 FE                trap_ne
001CF1  1  88                   dey
001CF2  1  10 E1                bpl tlday3
001CF4  1               
001CF4  1  A0 03                ldy #3      ;testing store result
001CF6  1  A2 00                ldx #0
001CF8  1  B9 03 02     tstay1: lda abst,y
001CFB  1  49 C3                eor #$c3
001CFD  1  D9 17 02             cmp abs1,y
001D00  1  D0 FE                trap_ne     ;store to abs data
001D02  1  8A                   txa
001D03  1  99 03 02             sta abst,y  ;clear
001D06  1  88                   dey
001D07  1  10 EF                bpl tstay1
001D09  1               
001D09  1  A2 06                ldx #6
001D0B  1  A0 03                ldy #3
001D0D  1               tldax4:
001D0D  1  A9 00 48 28          set_stat 0
001D11  1  A1 24                lda (ind1,x)
001D13  1  08                   php         ;test stores do not alter flags
001D14  1  49 C3                eor #$c3
001D16  1  28                   plp
001D17  1  81 30                sta (indt,x)
001D19  1  08                   php         ;flags after load/store sequence
001D1A  1  49 C3                eor #$c3
001D1C  1  D9 17 02             cmp abs1,y  ;test result
001D1F  1  D0 FE                trap_ne
001D21  1  68                   pla         ;load status
001D22  1  49 30                eor_flag 0
001D24  1  D9 1C 02             cmp fLDx,y  ;test flags
001D27  1  D0 FE                trap_ne
001D29  1  CA                   dex
001D2A  1  CA                   dex
001D2B  1  88                   dey
001D2C  1  10 DF                bpl tldax4
001D2E  1               
001D2E  1  A2 06                ldx #6
001D30  1  A0 03                ldy #3
001D32  1               tldax5:
001D32  1  A9 FF 48 28          set_stat $ff
001D36  1  A1 24                lda (ind1,x)
001D38  1  08                   php         ;test stores do not alter flags
001D39  1  49 C3                eor #$c3
001D3B  1  28                   plp
001D3C  1  81 30                sta (indt,x)
001D3E  1  08                   php         ;flags after load/store sequence
001D3F  1  49 C3                eor #$c3
001D41  1  D9 17 02             cmp abs1,y  ;test result
001D44  1  D0 FE                trap_ne
001D46  1  68                   pla         ;load status
001D47  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D49  1  D9 1C 02             cmp fLDx,y  ;test flags
001D4C  1  D0 FE                trap_ne
001D4E  1  CA                   dex
001D4F  1  CA                   dex
001D50  1  88                   dey
001D51  1  10 DF                bpl tldax5
001D53  1               
001D53  1  A0 03                ldy #3      ;testing store result
001D55  1  A2 00                ldx #0
001D57  1  B9 03 02     tstay2: lda abst,y
001D5A  1  49 C3                eor #$c3
001D5C  1  D9 17 02             cmp abs1,y
001D5F  1  D0 FE                trap_ne     ;store to abs data
001D61  1  8A                   txa
001D62  1  99 03 02             sta abst,y  ;clear
001D65  1  88                   dey
001D66  1  10 EF                bpl tstay2
001D68  1  AD 00 02 C9          next_test
001D6C  1  16 D0 FE A9  
001D70  1  17 8D 00 02  
001DB1  1               
001DB1  1               ; indexed wraparound test (only zp should wrap)
001DB1  1  A2 FD                ldx #3+$fa
001DB3  1  B5 19        tldax6: lda <(zp1-$fa),x   ;wrap on indexed zp
001DB5  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
001DB8  1  CA                   dex
001DB9  1  E0 FA                cpx #$fa
001DBB  1  B0 F6                bcs tldax6
001DBD  1  A2 FD                ldx #3+$fa
001DBF  1  BD 1D 01     tldax7: lda abs1-$fa,x      ;no wrap on indexed abs
001DC2  1  95 12                sta <(zpt-$fa),x
001DC4  1  CA                   dex
001DC5  1  E0 FA                cpx #$fa
001DC7  1  B0 F6                bcs tldax7
001DC9  1               
001DC9  1  A2 03                ldx #3      ;testing wraparound result
001DCB  1  A0 00                ldy #0
001DCD  1  B5 0C        tstax1: lda zpt,x
001DCF  1  D5 13                cmp zp1,x
001DD1  1  D0 FE                trap_ne     ;store to zp,x data
001DD3  1  94 0C                sty zpt,x   ;clear
001DD5  1  BD 03 02             lda abst,x
001DD8  1  DD 17 02             cmp abs1,x
001DDB  1  D0 FE                trap_ne     ;store to abs,x data
001DDD  1  8A                   txa
001DDE  1  9D 03 02             sta abst,x  ;clear
001DE1  1  CA                   dex
001DE2  1  10 E9                bpl tstax1
001DE4  1               
001DE4  1  A0 FB                ldy #3+$f8
001DE6  1  A2 FE                ldx #6+$f8
001DE8  1  A1 2C        tlday4: lda (<(ind1-$f8),x) ;wrap on indexed zp indirect
001DEA  1  99 0B 01             sta abst-$f8,y
001DED  1  CA                   dex
001DEE  1  CA                   dex
001DEF  1  88                   dey
001DF0  1  C0 F8                cpy #$f8
001DF2  1  B0 F4                bcs tlday4
001DF4  1  A0 03                ldy #3      ;testing wraparound result
001DF6  1  A2 00                ldx #0
001DF8  1  B9 03 02     tstay4: lda abst,y
001DFB  1  D9 17 02             cmp abs1,y
001DFE  1  D0 FE                trap_ne     ;store to abs data
001E00  1  8A                   txa
001E01  1  99 03 02             sta abst,y  ;clear
001E04  1  88                   dey
001E05  1  10 F1                bpl tstay4
001E07  1               
001E07  1  A0 FB                ldy #3+$f8
001E09  1  B9 1F 01     tlday5: lda abs1-$f8,y  ;no wrap on indexed abs
001E0C  1  91 38                sta (inwt),y
001E0E  1  88                   dey
001E0F  1  C0 F8                cpy #$f8
001E11  1  B0 F6                bcs tlday5
001E13  1  A0 03                ldy #3      ;testing wraparound result
001E15  1  A2 00                ldx #0
001E17  1  B9 03 02     tstay5: lda abst,y
001E1A  1  D9 17 02             cmp abs1,y
001E1D  1  D0 FE                trap_ne     ;store to abs data
001E1F  1  8A                   txa
001E20  1  99 03 02             sta abst,y  ;clear
001E23  1  88                   dey
001E24  1  10 F1                bpl tstay5
001E26  1               
001E26  1  A0 FB                ldy #3+$f8
001E28  1  A2 FE                ldx #6+$f8
001E2A  1  B1 2E        tlday6: lda (inw1),y    ;no wrap on zp indirect indexed
001E2C  1  81 38                sta (<(indt-$f8),x)
001E2E  1  CA                   dex
001E2F  1  CA                   dex
001E30  1  88                   dey
001E31  1  C0 F8                cpy #$f8
001E33  1  B0 F5                bcs tlday6
001E35  1  A0 03                ldy #3      ;testing wraparound result
001E37  1  A2 00                ldx #0
001E39  1  B9 03 02     tstay6: lda abst,y
001E3C  1  D9 17 02             cmp abs1,y
001E3F  1  D0 FE                trap_ne     ;store to abs data
001E41  1  8A                   txa
001E42  1  99 03 02             sta abst,y  ;clear
001E45  1  88                   dey
001E46  1  10 F1                bpl tstay6
001E48  1  AD 00 02 C9          next_test
001E4C  1  17 D0 FE A9  
001E50  1  18 8D 00 02  
001E91  1               
001E91  1               ; LDA / STA - zp / abs / #
001E91  1  A9 00 48 28          set_stat 0
001E95  1  A5 13                lda zp1
001E97  1  08                   php         ;test stores do not alter flags
001E98  1  49 C3                eor #$c3
001E9A  1  28                   plp
001E9B  1  8D 03 02             sta abst
001E9E  1  08                   php         ;flags after load/store sequence
001E9F  1  49 C3                eor #$c3
001EA1  1  C9 C3                cmp #$c3    ;test result
001EA3  1  D0 FE                trap_ne
001EA5  1  68                   pla         ;load status
001EA6  1  49 30                eor_flag 0
001EA8  1  CD 1C 02             cmp fLDx    ;test flags
001EAB  1  D0 FE                trap_ne
001EAD  1  A9 00 48 28          set_stat 0
001EB1  1  A5 14                lda zp1+1
001EB3  1  08                   php         ;test stores do not alter flags
001EB4  1  49 C3                eor #$c3
001EB6  1  28                   plp
001EB7  1  8D 04 02             sta abst+1
001EBA  1  08                   php         ;flags after load/store sequence
001EBB  1  49 C3                eor #$c3
001EBD  1  C9 82                cmp #$82    ;test result
001EBF  1  D0 FE                trap_ne
001EC1  1  68                   pla         ;load status
001EC2  1  49 30                eor_flag 0
001EC4  1  CD 1D 02             cmp fLDx+1  ;test flags
001EC7  1  D0 FE                trap_ne
001EC9  1  A9 00 48 28          set_stat 0
001ECD  1  A5 15                lda zp1+2
001ECF  1  08                   php         ;test stores do not alter flags
001ED0  1  49 C3                eor #$c3
001ED2  1  28                   plp
001ED3  1  8D 05 02             sta abst+2
001ED6  1  08                   php         ;flags after load/store sequence
001ED7  1  49 C3                eor #$c3
001ED9  1  C9 41                cmp #$41    ;test result
001EDB  1  D0 FE                trap_ne
001EDD  1  68                   pla         ;load status
001EDE  1  49 30                eor_flag 0
001EE0  1  CD 1E 02             cmp fLDx+2  ;test flags
001EE3  1  D0 FE                trap_ne
001EE5  1  A9 00 48 28          set_stat 0
001EE9  1  A5 16                lda zp1+3
001EEB  1  08                   php         ;test stores do not alter flags
001EEC  1  49 C3                eor #$c3
001EEE  1  28                   plp
001EEF  1  8D 06 02             sta abst+3
001EF2  1  08                   php         ;flags after load/store sequence
001EF3  1  49 C3                eor #$c3
001EF5  1  C9 00                cmp #0      ;test result
001EF7  1  D0 FE                trap_ne
001EF9  1  68                   pla         ;load status
001EFA  1  49 30                eor_flag 0
001EFC  1  CD 1F 02             cmp fLDx+3  ;test flags
001EFF  1  D0 FE                trap_ne
001F01  1  A9 FF 48 28          set_stat $ff
001F05  1  A5 13                lda zp1
001F07  1  08                   php         ;test stores do not alter flags
001F08  1  49 C3                eor #$c3
001F0A  1  28                   plp
001F0B  1  8D 03 02             sta abst
001F0E  1  08                   php         ;flags after load/store sequence
001F0F  1  49 C3                eor #$c3
001F11  1  C9 C3                cmp #$c3    ;test result
001F13  1  D0 FE                trap_ne
001F15  1  68                   pla         ;load status
001F16  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F18  1  CD 1C 02             cmp fLDx    ;test flags
001F1B  1  D0 FE                trap_ne
001F1D  1  A9 FF 48 28          set_stat $ff
001F21  1  A5 14                lda zp1+1
001F23  1  08                   php         ;test stores do not alter flags
001F24  1  49 C3                eor #$c3
001F26  1  28                   plp
001F27  1  8D 04 02             sta abst+1
001F2A  1  08                   php         ;flags after load/store sequence
001F2B  1  49 C3                eor #$c3
001F2D  1  C9 82                cmp #$82    ;test result
001F2F  1  D0 FE                trap_ne
001F31  1  68                   pla         ;load status
001F32  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F34  1  CD 1D 02             cmp fLDx+1  ;test flags
001F37  1  D0 FE                trap_ne
001F39  1  A9 FF 48 28          set_stat $ff
001F3D  1  A5 15                lda zp1+2
001F3F  1  08                   php         ;test stores do not alter flags
001F40  1  49 C3                eor #$c3
001F42  1  28                   plp
001F43  1  8D 05 02             sta abst+2
001F46  1  08                   php         ;flags after load/store sequence
001F47  1  49 C3                eor #$c3
001F49  1  C9 41                cmp #$41    ;test result
001F4B  1  D0 FE                trap_ne
001F4D  1  68                   pla         ;load status
001F4E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F50  1  CD 1E 02             cmp fLDx+2  ;test flags
001F53  1  D0 FE                trap_ne
001F55  1  A9 FF 48 28          set_stat $ff
001F59  1  A5 16                lda zp1+3
001F5B  1  08                   php         ;test stores do not alter flags
001F5C  1  49 C3                eor #$c3
001F5E  1  28                   plp
001F5F  1  8D 06 02             sta abst+3
001F62  1  08                   php         ;flags after load/store sequence
001F63  1  49 C3                eor #$c3
001F65  1  C9 00                cmp #0      ;test result
001F67  1  D0 FE                trap_ne
001F69  1  68                   pla         ;load status
001F6A  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F6C  1  CD 1F 02             cmp fLDx+3  ;test flags
001F6F  1  D0 FE                trap_ne
001F71  1  A9 00 48 28          set_stat 0
001F75  1  AD 17 02             lda abs1
001F78  1  08                   php         ;test stores do not alter flags
001F79  1  49 C3                eor #$c3
001F7B  1  28                   plp
001F7C  1  85 0C                sta zpt
001F7E  1  08                   php         ;flags after load/store sequence
001F7F  1  49 C3                eor #$c3
001F81  1  C5 13                cmp zp1     ;test result
001F83  1  D0 FE                trap_ne
001F85  1  68                   pla         ;load status
001F86  1  49 30                eor_flag 0
001F88  1  CD 1C 02             cmp fLDx    ;test flags
001F8B  1  D0 FE                trap_ne
001F8D  1  A9 00 48 28          set_stat 0
001F91  1  AD 18 02             lda abs1+1
001F94  1  08                   php         ;test stores do not alter flags
001F95  1  49 C3                eor #$c3
001F97  1  28                   plp
001F98  1  85 0D                sta zpt+1
001F9A  1  08                   php         ;flags after load/store sequence
001F9B  1  49 C3                eor #$c3
001F9D  1  C5 14                cmp zp1+1   ;test result
001F9F  1  D0 FE                trap_ne
001FA1  1  68                   pla         ;load status
001FA2  1  49 30                eor_flag 0
001FA4  1  CD 1D 02             cmp fLDx+1  ;test flags
001FA7  1  D0 FE                trap_ne
001FA9  1  A9 00 48 28          set_stat 0
001FAD  1  AD 19 02             lda abs1+2
001FB0  1  08                   php         ;test stores do not alter flags
001FB1  1  49 C3                eor #$c3
001FB3  1  28                   plp
001FB4  1  85 0E                sta zpt+2
001FB6  1  08                   php         ;flags after load/store sequence
001FB7  1  49 C3                eor #$c3
001FB9  1  C5 15                cmp zp1+2   ;test result
001FBB  1  D0 FE                trap_ne
001FBD  1  68                   pla         ;load status
001FBE  1  49 30                eor_flag 0
001FC0  1  CD 1E 02             cmp fLDx+2  ;test flags
001FC3  1  D0 FE                trap_ne
001FC5  1  A9 00 48 28          set_stat 0
001FC9  1  AD 1A 02             lda abs1+3
001FCC  1  08                   php         ;test stores do not alter flags
001FCD  1  49 C3                eor #$c3
001FCF  1  28                   plp
001FD0  1  85 0F                sta zpt+3
001FD2  1  08                   php         ;flags after load/store sequence
001FD3  1  49 C3                eor #$c3
001FD5  1  C5 16                cmp zp1+3   ;test result
001FD7  1  D0 FE                trap_ne
001FD9  1  68                   pla         ;load status
001FDA  1  49 30                eor_flag 0
001FDC  1  CD 1F 02             cmp fLDx+3  ;test flags
001FDF  1  D0 FE                trap_ne
001FE1  1  A9 FF 48 28          set_stat $ff
001FE5  1  AD 17 02             lda abs1
001FE8  1  08                   php         ;test stores do not alter flags
001FE9  1  49 C3                eor #$c3
001FEB  1  28                   plp
001FEC  1  85 0C                sta zpt
001FEE  1  08                   php         ;flags after load/store sequence
001FEF  1  49 C3                eor #$c3
001FF1  1  C5 13                cmp zp1     ;test result
001FF3  1  D0 FE                trap_ne
001FF5  1  68                   pla         ;load status
001FF6  1  49 7D                eor_flag <~fnz ;mask bits not altered
001FF8  1  CD 1C 02             cmp fLDx    ;test flags
001FFB  1  D0 FE                trap_ne
001FFD  1  A9 FF 48 28          set_stat $ff
002001  1  AD 18 02             lda abs1+1
002004  1  08                   php         ;test stores do not alter flags
002005  1  49 C3                eor #$c3
002007  1  28                   plp
002008  1  85 0D                sta zpt+1
00200A  1  08                   php         ;flags after load/store sequence
00200B  1  49 C3                eor #$c3
00200D  1  C5 14                cmp zp1+1   ;test result
00200F  1  D0 FE                trap_ne
002011  1  68                   pla         ;load status
002012  1  49 7D                eor_flag <~fnz ;mask bits not altered
002014  1  CD 1D 02             cmp fLDx+1  ;test flags
002017  1  D0 FE                trap_ne
002019  1  A9 FF 48 28          set_stat $ff
00201D  1  AD 19 02             lda abs1+2
002020  1  08                   php         ;test stores do not alter flags
002021  1  49 C3                eor #$c3
002023  1  28                   plp
002024  1  85 0E                sta zpt+2
002026  1  08                   php         ;flags after load/store sequence
002027  1  49 C3                eor #$c3
002029  1  C5 15                cmp zp1+2   ;test result
00202B  1  D0 FE                trap_ne
00202D  1  68                   pla         ;load status
00202E  1  49 7D                eor_flag <~fnz ;mask bits not altered
002030  1  CD 1E 02             cmp fLDx+2  ;test flags
002033  1  D0 FE                trap_ne
002035  1  A9 FF 48 28          set_stat $ff
002039  1  AD 1A 02             lda abs1+3
00203C  1  08                   php         ;test stores do not alter flags
00203D  1  49 C3                eor #$c3
00203F  1  28                   plp
002040  1  85 0F                sta zpt+3
002042  1  08                   php         ;flags after load/store sequence
002043  1  49 C3                eor #$c3
002045  1  C5 16                cmp zp1+3   ;test result
002047  1  D0 FE                trap_ne
002049  1  68                   pla         ;load status
00204A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00204C  1  CD 1F 02             cmp fLDx+3  ;test flags
00204F  1  D0 FE                trap_ne
002051  1  A9 00 48 28          set_stat 0
002055  1  A9 C3                lda #$c3
002057  1  08                   php
002058  1  CD 17 02             cmp abs1    ;test result
00205B  1  D0 FE                trap_ne
00205D  1  68                   pla         ;load status
00205E  1  49 30                eor_flag 0
002060  1  CD 1C 02             cmp fLDx    ;test flags
002063  1  D0 FE                trap_ne
002065  1  A9 00 48 28          set_stat 0
002069  1  A9 82                lda #$82
00206B  1  08                   php
00206C  1  CD 18 02             cmp abs1+1  ;test result
00206F  1  D0 FE                trap_ne
002071  1  68                   pla         ;load status
002072  1  49 30                eor_flag 0
002074  1  CD 1D 02             cmp fLDx+1  ;test flags
002077  1  D0 FE                trap_ne
002079  1  A9 00 48 28          set_stat 0
00207D  1  A9 41                lda #$41
00207F  1  08                   php
002080  1  CD 19 02             cmp abs1+2  ;test result
002083  1  D0 FE                trap_ne
002085  1  68                   pla         ;load status
002086  1  49 30                eor_flag 0
002088  1  CD 1E 02             cmp fLDx+2  ;test flags
00208B  1  D0 FE                trap_ne
00208D  1  A9 00 48 28          set_stat 0
002091  1  A9 00                lda #0
002093  1  08                   php
002094  1  CD 1A 02             cmp abs1+3  ;test result
002097  1  D0 FE                trap_ne
002099  1  68                   pla         ;load status
00209A  1  49 30                eor_flag 0
00209C  1  CD 1F 02             cmp fLDx+3  ;test flags
00209F  1  D0 FE                trap_ne
0020A1  1               
0020A1  1  A9 FF 48 28          set_stat $ff
0020A5  1  A9 C3                lda #$c3
0020A7  1  08                   php
0020A8  1  CD 17 02             cmp abs1    ;test result
0020AB  1  D0 FE                trap_ne
0020AD  1  68                   pla         ;load status
0020AE  1  49 7D                eor_flag <~fnz ;mask bits not altered
0020B0  1  CD 1C 02             cmp fLDx    ;test flags
0020B3  1  D0 FE                trap_ne
0020B5  1  A9 FF 48 28          set_stat $ff
0020B9  1  A9 82                lda #$82
0020BB  1  08                   php
0020BC  1  CD 18 02             cmp abs1+1  ;test result
0020BF  1  D0 FE                trap_ne
0020C1  1  68                   pla         ;load status
0020C2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0020C4  1  CD 1D 02             cmp fLDx+1  ;test flags
0020C7  1  D0 FE                trap_ne
0020C9  1  A9 FF 48 28          set_stat $ff
0020CD  1  A9 41                lda #$41
0020CF  1  08                   php
0020D0  1  CD 19 02             cmp abs1+2  ;test result
0020D3  1  D0 FE                trap_ne
0020D5  1  68                   pla         ;load status
0020D6  1  49 7D                eor_flag <~fnz ;mask bits not altered
0020D8  1  CD 1E 02             cmp fLDx+2  ;test flags
0020DB  1  D0 FE                trap_ne
0020DD  1  A9 FF 48 28          set_stat $ff
0020E1  1  A9 00                lda #0
0020E3  1  08                   php
0020E4  1  CD 1A 02             cmp abs1+3  ;test result
0020E7  1  D0 FE                trap_ne
0020E9  1  68                   pla         ;load status
0020EA  1  49 7D                eor_flag <~fnz ;mask bits not altered
0020EC  1  CD 1F 02             cmp fLDx+3  ;test flags
0020EF  1  D0 FE                trap_ne
0020F1  1               
0020F1  1  A2 00                ldx #0
0020F3  1  A5 0C                lda zpt
0020F5  1  49 C3                eor #$c3
0020F7  1  C5 13                cmp zp1
0020F9  1  D0 FE                trap_ne     ;store to zp data
0020FB  1  86 0C                stx zpt     ;clear
0020FD  1  AD 03 02             lda abst
002100  1  49 C3                eor #$c3
002102  1  CD 17 02             cmp abs1
002105  1  D0 FE                trap_ne     ;store to abs data
002107  1  8E 03 02             stx abst    ;clear
00210A  1  A5 0D                lda zpt+1
00210C  1  49 C3                eor #$c3
00210E  1  C5 14                cmp zp1+1
002110  1  D0 FE                trap_ne     ;store to zp data
002112  1  86 0D                stx zpt+1   ;clear
002114  1  AD 04 02             lda abst+1
002117  1  49 C3                eor #$c3
002119  1  CD 18 02             cmp abs1+1
00211C  1  D0 FE                trap_ne     ;store to abs data
00211E  1  8E 04 02             stx abst+1  ;clear
002121  1  A5 0E                lda zpt+2
002123  1  49 C3                eor #$c3
002125  1  C5 15                cmp zp1+2
002127  1  D0 FE                trap_ne     ;store to zp data
002129  1  86 0E                stx zpt+2   ;clear
00212B  1  AD 05 02             lda abst+2
00212E  1  49 C3                eor #$c3
002130  1  CD 19 02             cmp abs1+2
002133  1  D0 FE                trap_ne     ;store to abs data
002135  1  8E 05 02             stx abst+2  ;clear
002138  1  A5 0F                lda zpt+3
00213A  1  49 C3                eor #$c3
00213C  1  C5 16                cmp zp1+3
00213E  1  D0 FE                trap_ne     ;store to zp data
002140  1  86 0F                stx zpt+3   ;clear
002142  1  AD 06 02             lda abst+3
002145  1  49 C3                eor #$c3
002147  1  CD 1A 02             cmp abs1+3
00214A  1  D0 FE                trap_ne     ;store to abs data
00214C  1  8E 06 02             stx abst+3  ;clear
00214F  1  AD 00 02 C9          next_test
002153  1  18 D0 FE A9  
002157  1  19 8D 00 02  
002198  1               
002198  1               ; testing bit test & compares BIT CPX CPY CMP all addressing modes
002198  1               ; BIT - zp / abs
002198  1  A9 00 48 A9          set_a $ff,0
00219C  1  FF 28        
00219E  1  24 16                bit zp1+3   ;00 - should set Z / clear  NV
0021A0  1  08 C9 FF D0          tst_a $ff,fz
0021A4  1  FE 68 48 C9  
0021A8  1  32 D0 FE 28  
0021AC  1  A9 00 48 A9          set_a 1,0
0021B0  1  01 28        
0021B2  1  24 15                bit zp1+2   ;41 - should set V (M6) / clear NZ
0021B4  1  08 C9 01 D0          tst_a 1,fv
0021B8  1  FE 68 48 C9  
0021BC  1  70 D0 FE 28  
0021C0  1  A9 00 48 A9          set_a 1,0
0021C4  1  01 28        
0021C6  1  24 14                bit zp1+1   ;82 - should set N (M7) & Z / clear V
0021C8  1  08 C9 01 D0          tst_a 1,fnz
0021CC  1  FE 68 48 C9  
0021D0  1  B2 D0 FE 28  
0021D4  1  A9 00 48 A9          set_a 1,0
0021D8  1  01 28        
0021DA  1  24 13                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
0021DC  1  08 C9 01 D0          tst_a 1,fnv
0021E0  1  FE 68 48 C9  
0021E4  1  F0 D0 FE 28  
0021E8  1               
0021E8  1  A9 FF 48 A9          set_a $ff,$ff
0021EC  1  FF 28        
0021EE  1  24 16                bit zp1+3   ;00 - should set Z / clear  NV
0021F0  1  08 C9 FF D0          tst_a $ff,~fnv
0021F4  1  FE 68 48 C9  
0021F8  1  3F D0 FE 28  
0021FC  1  A9 FF 48 A9          set_a 1,$ff
002200  1  01 28        
002202  1  24 15                bit zp1+2   ;41 - should set V (M6) / clear NZ
002204  1  08 C9 01 D0          tst_a 1,~fnz
002208  1  FE 68 48 C9  
00220C  1  7D D0 FE 28  
002210  1  A9 FF 48 A9          set_a 1,$ff
002214  1  01 28        
002216  1  24 14                bit zp1+1   ;82 - should set N (M7) & Z / clear V
002218  1  08 C9 01 D0          tst_a 1,~fv
00221C  1  FE 68 48 C9  
002220  1  BF D0 FE 28  
002224  1  A9 FF 48 A9          set_a 1,$ff
002228  1  01 28        
00222A  1  24 13                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
00222C  1  08 C9 01 D0          tst_a 1,~fz
002230  1  FE 68 48 C9  
002234  1  FD D0 FE 28  
002238  1               
002238  1  A9 00 48 A9          set_a $ff,0
00223C  1  FF 28        
00223E  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
002241  1  08 C9 FF D0          tst_a $ff,fz
002245  1  FE 68 48 C9  
002249  1  32 D0 FE 28  
00224D  1  A9 00 48 A9          set_a 1,0
002251  1  01 28        
002253  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
002256  1  08 C9 01 D0          tst_a 1,fv
00225A  1  FE 68 48 C9  
00225E  1  70 D0 FE 28  
002262  1  A9 00 48 A9          set_a 1,0
002266  1  01 28        
002268  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
00226B  1  08 C9 01 D0          tst_a 1,fnz
00226F  1  FE 68 48 C9  
002273  1  B2 D0 FE 28  
002277  1  A9 00 48 A9          set_a 1,0
00227B  1  01 28        
00227D  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
002280  1  08 C9 01 D0          tst_a 1,fnv
002284  1  FE 68 48 C9  
002288  1  F0 D0 FE 28  
00228C  1               
00228C  1  A9 FF 48 A9          set_a $ff,$ff
002290  1  FF 28        
002292  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
002295  1  08 C9 FF D0          tst_a $ff,~fnv
002299  1  FE 68 48 C9  
00229D  1  3F D0 FE 28  
0022A1  1  A9 FF 48 A9          set_a 1,$ff
0022A5  1  01 28        
0022A7  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
0022AA  1  08 C9 01 D0          tst_a 1,~fnz
0022AE  1  FE 68 48 C9  
0022B2  1  7D D0 FE 28  
0022B6  1  A9 FF 48 A9          set_a 1,$ff
0022BA  1  01 28        
0022BC  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
0022BF  1  08 C9 01 D0          tst_a 1,~fv
0022C3  1  FE 68 48 C9  
0022C7  1  BF D0 FE 28  
0022CB  1  A9 FF 48 A9          set_a 1,$ff
0022CF  1  01 28        
0022D1  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
0022D4  1  08 C9 01 D0          tst_a 1,~fz
0022D8  1  FE 68 48 C9  
0022DC  1  FD D0 FE 28  
0022E0  1  AD 00 02 C9          next_test
0022E4  1  19 D0 FE A9  
0022E8  1  1A 8D 00 02  
002329  1               
002329  1               ; CPX - zp / abs / #
002329  1  A9 00 48 A2          set_x $80,0
00232D  1  80 28        
00232F  1  E4 17                cpx zp7f
002331  1  08 68 48 C9          tst_stat fc
002335  1  31 D0 FE 28  
002339  1  CA                   dex
00233A  1  E4 17                cpx zp7f
00233C  1  08 68 48 C9          tst_stat fzc
002340  1  33 D0 FE 28  
002344  1  CA                   dex
002345  1  E4 17                cpx zp7f
002347  1  08 E0 7E D0          tst_x $7e,fn
00234B  1  FE 68 48 C9  
00234F  1  B0 D0 FE 28  
002353  1  A9 FF 48 A2          set_x $80,$ff
002357  1  80 28        
002359  1  E4 17                cpx zp7f
00235B  1  08 68 48 C9          tst_stat ~fnz
00235F  1  7D D0 FE 28  
002363  1  CA                   dex
002364  1  E4 17                cpx zp7f
002366  1  08 68 48 C9          tst_stat ~fn
00236A  1  7F D0 FE 28  
00236E  1  CA                   dex
00236F  1  E4 17                cpx zp7f
002371  1  08 E0 7E D0          tst_x $7e,~fzc
002375  1  FE 68 48 C9  
002379  1  FC D0 FE 28  
00237D  1               
00237D  1  A9 00 48 A2          set_x $80,0
002381  1  80 28        
002383  1  EC 1B 02             cpx abs7f
002386  1  08 68 48 C9          tst_stat fc
00238A  1  31 D0 FE 28  
00238E  1  CA                   dex
00238F  1  EC 1B 02             cpx abs7f
002392  1  08 68 48 C9          tst_stat fzc
002396  1  33 D0 FE 28  
00239A  1  CA                   dex
00239B  1  EC 1B 02             cpx abs7f
00239E  1  08 E0 7E D0          tst_x $7e,fn
0023A2  1  FE 68 48 C9  
0023A6  1  B0 D0 FE 28  
0023AA  1  A9 FF 48 A2          set_x $80,$ff
0023AE  1  80 28        
0023B0  1  EC 1B 02             cpx abs7f
0023B3  1  08 68 48 C9          tst_stat ~fnz
0023B7  1  7D D0 FE 28  
0023BB  1  CA                   dex
0023BC  1  EC 1B 02             cpx abs7f
0023BF  1  08 68 48 C9          tst_stat ~fn
0023C3  1  7F D0 FE 28  
0023C7  1  CA                   dex
0023C8  1  EC 1B 02             cpx abs7f
0023CB  1  08 E0 7E D0          tst_x $7e,~fzc
0023CF  1  FE 68 48 C9  
0023D3  1  FC D0 FE 28  
0023D7  1               
0023D7  1  A9 00 48 A2          set_x $80,0
0023DB  1  80 28        
0023DD  1  E0 7F                cpx #$7f
0023DF  1  08 68 48 C9          tst_stat fc
0023E3  1  31 D0 FE 28  
0023E7  1  CA                   dex
0023E8  1  E0 7F                cpx #$7f
0023EA  1  08 68 48 C9          tst_stat fzc
0023EE  1  33 D0 FE 28  
0023F2  1  CA                   dex
0023F3  1  E0 7F                cpx #$7f
0023F5  1  08 E0 7E D0          tst_x $7e,fn
0023F9  1  FE 68 48 C9  
0023FD  1  B0 D0 FE 28  
002401  1  A9 FF 48 A2          set_x $80,$ff
002405  1  80 28        
002407  1  E0 7F                cpx #$7f
002409  1  08 68 48 C9          tst_stat ~fnz
00240D  1  7D D0 FE 28  
002411  1  CA                   dex
002412  1  E0 7F                cpx #$7f
002414  1  08 68 48 C9          tst_stat ~fn
002418  1  7F D0 FE 28  
00241C  1  CA                   dex
00241D  1  E0 7F                cpx #$7f
00241F  1  08 E0 7E D0          tst_x $7e,~fzc
002423  1  FE 68 48 C9  
002427  1  FC D0 FE 28  
00242B  1  AD 00 02 C9          next_test
00242F  1  1A D0 FE A9  
002433  1  1B 8D 00 02  
002474  1               
002474  1               ; CPY - zp / abs / #
002474  1  A9 00 48 A0          set_y $80,0
002478  1  80 28        
00247A  1  C4 17                cpy zp7f
00247C  1  08 68 48 C9          tst_stat fc
002480  1  31 D0 FE 28  
002484  1  88                   dey
002485  1  C4 17                cpy zp7f
002487  1  08 68 48 C9          tst_stat fzc
00248B  1  33 D0 FE 28  
00248F  1  88                   dey
002490  1  C4 17                cpy zp7f
002492  1  08 C0 7E D0          tst_y $7e,fn
002496  1  FE 68 48 C9  
00249A  1  B0 D0 FE 28  
00249E  1  A9 FF 48 A0          set_y $80,$ff
0024A2  1  80 28        
0024A4  1  C4 17                cpy zp7f
0024A6  1  08 68 48 C9          tst_stat ~fnz
0024AA  1  7D D0 FE 28  
0024AE  1  88                   dey
0024AF  1  C4 17                cpy zp7f
0024B1  1  08 68 48 C9          tst_stat ~fn
0024B5  1  7F D0 FE 28  
0024B9  1  88                   dey
0024BA  1  C4 17                cpy zp7f
0024BC  1  08 C0 7E D0          tst_y $7e,~fzc
0024C0  1  FE 68 48 C9  
0024C4  1  FC D0 FE 28  
0024C8  1               
0024C8  1  A9 00 48 A0          set_y $80,0
0024CC  1  80 28        
0024CE  1  CC 1B 02             cpy abs7f
0024D1  1  08 68 48 C9          tst_stat fc
0024D5  1  31 D0 FE 28  
0024D9  1  88                   dey
0024DA  1  CC 1B 02             cpy abs7f
0024DD  1  08 68 48 C9          tst_stat fzc
0024E1  1  33 D0 FE 28  
0024E5  1  88                   dey
0024E6  1  CC 1B 02             cpy abs7f
0024E9  1  08 C0 7E D0          tst_y $7e,fn
0024ED  1  FE 68 48 C9  
0024F1  1  B0 D0 FE 28  
0024F5  1  A9 FF 48 A0          set_y $80,$ff
0024F9  1  80 28        
0024FB  1  CC 1B 02             cpy abs7f
0024FE  1  08 68 48 C9          tst_stat ~fnz
002502  1  7D D0 FE 28  
002506  1  88                   dey
002507  1  CC 1B 02             cpy abs7f
00250A  1  08 68 48 C9          tst_stat ~fn
00250E  1  7F D0 FE 28  
002512  1  88                   dey
002513  1  CC 1B 02             cpy abs7f
002516  1  08 C0 7E D0          tst_y $7e,~fzc
00251A  1  FE 68 48 C9  
00251E  1  FC D0 FE 28  
002522  1               
002522  1  A9 00 48 A0          set_y $80,0
002526  1  80 28        
002528  1  C0 7F                cpy #$7f
00252A  1  08 68 48 C9          tst_stat fc
00252E  1  31 D0 FE 28  
002532  1  88                   dey
002533  1  C0 7F                cpy #$7f
002535  1  08 68 48 C9          tst_stat fzc
002539  1  33 D0 FE 28  
00253D  1  88                   dey
00253E  1  C0 7F                cpy #$7f
002540  1  08 C0 7E D0          tst_y $7e,fn
002544  1  FE 68 48 C9  
002548  1  B0 D0 FE 28  
00254C  1  A9 FF 48 A0          set_y $80,$ff
002550  1  80 28        
002552  1  C0 7F                cpy #$7f
002554  1  08 68 48 C9          tst_stat ~fnz
002558  1  7D D0 FE 28  
00255C  1  88                   dey
00255D  1  C0 7F                cpy #$7f
00255F  1  08 68 48 C9          tst_stat ~fn
002563  1  7F D0 FE 28  
002567  1  88                   dey
002568  1  C0 7F                cpy #$7f
00256A  1  08 C0 7E D0          tst_y $7e,~fzc
00256E  1  FE 68 48 C9  
002572  1  FC D0 FE 28  
002576  1  AD 00 02 C9          next_test
00257A  1  1B D0 FE A9  
00257E  1  1C 8D 00 02  
0025BF  1               
0025BF  1               ; CMP - zp / abs / #
0025BF  1  A9 00 48 A9          set_a $80,0
0025C3  1  80 28        
0025C5  1  C5 17                cmp zp7f
0025C7  1  08 C9 80 D0          tst_a $80,fc
0025CB  1  FE 68 48 C9  
0025CF  1  31 D0 FE 28  
0025D3  1  A9 00 48 A9          set_a $7f,0
0025D7  1  7F 28        
0025D9  1  C5 17                cmp zp7f
0025DB  1  08 C9 7F D0          tst_a $7f,fzc
0025DF  1  FE 68 48 C9  
0025E3  1  33 D0 FE 28  
0025E7  1  A9 00 48 A9          set_a $7e,0
0025EB  1  7E 28        
0025ED  1  C5 17                cmp zp7f
0025EF  1  08 C9 7E D0          tst_a $7e,fn
0025F3  1  FE 68 48 C9  
0025F7  1  B0 D0 FE 28  
0025FB  1  A9 FF 48 A9          set_a $80,$ff
0025FF  1  80 28        
002601  1  C5 17                cmp zp7f
002603  1  08 C9 80 D0          tst_a $80,~fnz
002607  1  FE 68 48 C9  
00260B  1  7D D0 FE 28  
00260F  1  A9 FF 48 A9          set_a $7f,$ff
002613  1  7F 28        
002615  1  C5 17                cmp zp7f
002617  1  08 C9 7F D0          tst_a $7f,~fn
00261B  1  FE 68 48 C9  
00261F  1  7F D0 FE 28  
002623  1  A9 FF 48 A9          set_a $7e,$ff
002627  1  7E 28        
002629  1  C5 17                cmp zp7f
00262B  1  08 C9 7E D0          tst_a $7e,~fzc
00262F  1  FE 68 48 C9  
002633  1  FC D0 FE 28  
002637  1               
002637  1  A9 00 48 A9          set_a $80,0
00263B  1  80 28        
00263D  1  CD 1B 02             cmp abs7f
002640  1  08 C9 80 D0          tst_a $80,fc
002644  1  FE 68 48 C9  
002648  1  31 D0 FE 28  
00264C  1  A9 00 48 A9          set_a $7f,0
002650  1  7F 28        
002652  1  CD 1B 02             cmp abs7f
002655  1  08 C9 7F D0          tst_a $7f,fzc
002659  1  FE 68 48 C9  
00265D  1  33 D0 FE 28  
002661  1  A9 00 48 A9          set_a $7e,0
002665  1  7E 28        
002667  1  CD 1B 02             cmp abs7f
00266A  1  08 C9 7E D0          tst_a $7e,fn
00266E  1  FE 68 48 C9  
002672  1  B0 D0 FE 28  
002676  1  A9 FF 48 A9          set_a $80,$ff
00267A  1  80 28        
00267C  1  CD 1B 02             cmp abs7f
00267F  1  08 C9 80 D0          tst_a $80,~fnz
002683  1  FE 68 48 C9  
002687  1  7D D0 FE 28  
00268B  1  A9 FF 48 A9          set_a $7f,$ff
00268F  1  7F 28        
002691  1  CD 1B 02             cmp abs7f
002694  1  08 C9 7F D0          tst_a $7f,~fn
002698  1  FE 68 48 C9  
00269C  1  7F D0 FE 28  
0026A0  1  A9 FF 48 A9          set_a $7e,$ff
0026A4  1  7E 28        
0026A6  1  CD 1B 02             cmp abs7f
0026A9  1  08 C9 7E D0          tst_a $7e,~fzc
0026AD  1  FE 68 48 C9  
0026B1  1  FC D0 FE 28  
0026B5  1               
0026B5  1  A9 00 48 A9          set_a $80,0
0026B9  1  80 28        
0026BB  1  C9 7F                cmp #$7f
0026BD  1  08 C9 80 D0          tst_a $80,fc
0026C1  1  FE 68 48 C9  
0026C5  1  31 D0 FE 28  
0026C9  1  A9 00 48 A9          set_a $7f,0
0026CD  1  7F 28        
0026CF  1  C9 7F                cmp #$7f
0026D1  1  08 C9 7F D0          tst_a $7f,fzc
0026D5  1  FE 68 48 C9  
0026D9  1  33 D0 FE 28  
0026DD  1  A9 00 48 A9          set_a $7e,0
0026E1  1  7E 28        
0026E3  1  C9 7F                cmp #$7f
0026E5  1  08 C9 7E D0          tst_a $7e,fn
0026E9  1  FE 68 48 C9  
0026ED  1  B0 D0 FE 28  
0026F1  1  A9 FF 48 A9          set_a $80,$ff
0026F5  1  80 28        
0026F7  1  C9 7F                cmp #$7f
0026F9  1  08 C9 80 D0          tst_a $80,~fnz
0026FD  1  FE 68 48 C9  
002701  1  7D D0 FE 28  
002705  1  A9 FF 48 A9          set_a $7f,$ff
002709  1  7F 28        
00270B  1  C9 7F                cmp #$7f
00270D  1  08 C9 7F D0          tst_a $7f,~fn
002711  1  FE 68 48 C9  
002715  1  7F D0 FE 28  
002719  1  A9 FF 48 A9          set_a $7e,$ff
00271D  1  7E 28        
00271F  1  C9 7F                cmp #$7f
002721  1  08 C9 7E D0          tst_a $7e,~fzc
002725  1  FE 68 48 C9  
002729  1  FC D0 FE 28  
00272D  1               
00272D  1  A2 04                ldx #4          ;with indexing by X
00272F  1  A9 00 48 A9          set_a $80,0
002733  1  80 28        
002735  1  D5 13                cmp zp1,x
002737  1  08 C9 80 D0          tst_a $80,fc
00273B  1  FE 68 48 C9  
00273F  1  31 D0 FE 28  
002743  1  A9 00 48 A9          set_a $7f,0
002747  1  7F 28        
002749  1  D5 13                cmp zp1,x
00274B  1  08 C9 7F D0          tst_a $7f,fzc
00274F  1  FE 68 48 C9  
002753  1  33 D0 FE 28  
002757  1  A9 00 48 A9          set_a $7e,0
00275B  1  7E 28        
00275D  1  D5 13                cmp zp1,x
00275F  1  08 C9 7E D0          tst_a $7e,fn
002763  1  FE 68 48 C9  
002767  1  B0 D0 FE 28  
00276B  1  A9 FF 48 A9          set_a $80,$ff
00276F  1  80 28        
002771  1  D5 13                cmp zp1,x
002773  1  08 C9 80 D0          tst_a $80,~fnz
002777  1  FE 68 48 C9  
00277B  1  7D D0 FE 28  
00277F  1  A9 FF 48 A9          set_a $7f,$ff
002783  1  7F 28        
002785  1  D5 13                cmp zp1,x
002787  1  08 C9 7F D0          tst_a $7f,~fn
00278B  1  FE 68 48 C9  
00278F  1  7F D0 FE 28  
002793  1  A9 FF 48 A9          set_a $7e,$ff
002797  1  7E 28        
002799  1  D5 13                cmp zp1,x
00279B  1  08 C9 7E D0          tst_a $7e,~fzc
00279F  1  FE 68 48 C9  
0027A3  1  FC D0 FE 28  
0027A7  1               
0027A7  1  A9 00 48 A9          set_a $80,0
0027AB  1  80 28        
0027AD  1  DD 17 02             cmp abs1,x
0027B0  1  08 C9 80 D0          tst_a $80,fc
0027B4  1  FE 68 48 C9  
0027B8  1  31 D0 FE 28  
0027BC  1  A9 00 48 A9          set_a $7f,0
0027C0  1  7F 28        
0027C2  1  DD 17 02             cmp abs1,x
0027C5  1  08 C9 7F D0          tst_a $7f,fzc
0027C9  1  FE 68 48 C9  
0027CD  1  33 D0 FE 28  
0027D1  1  A9 00 48 A9          set_a $7e,0
0027D5  1  7E 28        
0027D7  1  DD 17 02             cmp abs1,x
0027DA  1  08 C9 7E D0          tst_a $7e,fn
0027DE  1  FE 68 48 C9  
0027E2  1  B0 D0 FE 28  
0027E6  1  A9 FF 48 A9          set_a $80,$ff
0027EA  1  80 28        
0027EC  1  DD 17 02             cmp abs1,x
0027EF  1  08 C9 80 D0          tst_a $80,~fnz
0027F3  1  FE 68 48 C9  
0027F7  1  7D D0 FE 28  
0027FB  1  A9 FF 48 A9          set_a $7f,$ff
0027FF  1  7F 28        
002801  1  DD 17 02             cmp abs1,x
002804  1  08 C9 7F D0          tst_a $7f,~fn
002808  1  FE 68 48 C9  
00280C  1  7F D0 FE 28  
002810  1  A9 FF 48 A9          set_a $7e,$ff
002814  1  7E 28        
002816  1  DD 17 02             cmp abs1,x
002819  1  08 C9 7E D0          tst_a $7e,~fzc
00281D  1  FE 68 48 C9  
002821  1  FC D0 FE 28  
002825  1               
002825  1  A0 04                ldy #4          ;with indexing by Y
002827  1  A2 08                ldx #8          ;with indexed indirect
002829  1  A9 00 48 A9          set_a $80,0
00282D  1  80 28        
00282F  1  D9 17 02             cmp abs1,y
002832  1  08 C9 80 D0          tst_a $80,fc
002836  1  FE 68 48 C9  
00283A  1  31 D0 FE 28  
00283E  1  A9 00 48 A9          set_a $7f,0
002842  1  7F 28        
002844  1  D9 17 02             cmp abs1,y
002847  1  08 C9 7F D0          tst_a $7f,fzc
00284B  1  FE 68 48 C9  
00284F  1  33 D0 FE 28  
002853  1  A9 00 48 A9          set_a $7e,0
002857  1  7E 28        
002859  1  D9 17 02             cmp abs1,y
00285C  1  08 C9 7E D0          tst_a $7e,fn
002860  1  FE 68 48 C9  
002864  1  B0 D0 FE 28  
002868  1  A9 FF 48 A9          set_a $80,$ff
00286C  1  80 28        
00286E  1  D9 17 02             cmp abs1,y
002871  1  08 C9 80 D0          tst_a $80,~fnz
002875  1  FE 68 48 C9  
002879  1  7D D0 FE 28  
00287D  1  A9 FF 48 A9          set_a $7f,$ff
002881  1  7F 28        
002883  1  D9 17 02             cmp abs1,y
002886  1  08 C9 7F D0          tst_a $7f,~fn
00288A  1  FE 68 48 C9  
00288E  1  7F D0 FE 28  
002892  1  A9 FF 48 A9          set_a $7e,$ff
002896  1  7E 28        
002898  1  D9 17 02             cmp abs1,y
00289B  1  08 C9 7E D0          tst_a $7e,~fzc
00289F  1  FE 68 48 C9  
0028A3  1  FC D0 FE 28  
0028A7  1               
0028A7  1  A9 00 48 A9          set_a $80,0
0028AB  1  80 28        
0028AD  1  C1 24                cmp (ind1,x)
0028AF  1  08 C9 80 D0          tst_a $80,fc
0028B3  1  FE 68 48 C9  
0028B7  1  31 D0 FE 28  
0028BB  1  A9 00 48 A9          set_a $7f,0
0028BF  1  7F 28        
0028C1  1  C1 24                cmp (ind1,x)
0028C3  1  08 C9 7F D0          tst_a $7f,fzc
0028C7  1  FE 68 48 C9  
0028CB  1  33 D0 FE 28  
0028CF  1  A9 00 48 A9          set_a $7e,0
0028D3  1  7E 28        
0028D5  1  C1 24                cmp (ind1,x)
0028D7  1  08 C9 7E D0          tst_a $7e,fn
0028DB  1  FE 68 48 C9  
0028DF  1  B0 D0 FE 28  
0028E3  1  A9 FF 48 A9          set_a $80,$ff
0028E7  1  80 28        
0028E9  1  C1 24                cmp (ind1,x)
0028EB  1  08 C9 80 D0          tst_a $80,~fnz
0028EF  1  FE 68 48 C9  
0028F3  1  7D D0 FE 28  
0028F7  1  A9 FF 48 A9          set_a $7f,$ff
0028FB  1  7F 28        
0028FD  1  C1 24                cmp (ind1,x)
0028FF  1  08 C9 7F D0          tst_a $7f,~fn
002903  1  FE 68 48 C9  
002907  1  7F D0 FE 28  
00290B  1  A9 FF 48 A9          set_a $7e,$ff
00290F  1  7E 28        
002911  1  C1 24                cmp (ind1,x)
002913  1  08 C9 7E D0          tst_a $7e,~fzc
002917  1  FE 68 48 C9  
00291B  1  FC D0 FE 28  
00291F  1               
00291F  1  A9 00 48 A9          set_a $80,0
002923  1  80 28        
002925  1  D1 24                cmp (ind1),y
002927  1  08 C9 80 D0          tst_a $80,fc
00292B  1  FE 68 48 C9  
00292F  1  31 D0 FE 28  
002933  1  A9 00 48 A9          set_a $7f,0
002937  1  7F 28        
002939  1  D1 24                cmp (ind1),y
00293B  1  08 C9 7F D0          tst_a $7f,fzc
00293F  1  FE 68 48 C9  
002943  1  33 D0 FE 28  
002947  1  A9 00 48 A9          set_a $7e,0
00294B  1  7E 28        
00294D  1  D1 24                cmp (ind1),y
00294F  1  08 C9 7E D0          tst_a $7e,fn
002953  1  FE 68 48 C9  
002957  1  B0 D0 FE 28  
00295B  1  A9 FF 48 A9          set_a $80,$ff
00295F  1  80 28        
002961  1  D1 24                cmp (ind1),y
002963  1  08 C9 80 D0          tst_a $80,~fnz
002967  1  FE 68 48 C9  
00296B  1  7D D0 FE 28  
00296F  1  A9 FF 48 A9          set_a $7f,$ff
002973  1  7F 28        
002975  1  D1 24                cmp (ind1),y
002977  1  08 C9 7F D0          tst_a $7f,~fn
00297B  1  FE 68 48 C9  
00297F  1  7F D0 FE 28  
002983  1  A9 FF 48 A9          set_a $7e,$ff
002987  1  7E 28        
002989  1  D1 24                cmp (ind1),y
00298B  1  08 C9 7E D0          tst_a $7e,~fzc
00298F  1  FE 68 48 C9  
002993  1  FC D0 FE 28  
002997  1  AD 00 02 C9          next_test
00299B  1  1C D0 FE A9  
00299F  1  1D 8D 00 02  
0029E0  1               
0029E0  1               ; testing shifts - ASL LSR ROL ROR all addressing modes
0029E0  1               ; shifts - accumulator
0029E0  1  A2 03                ldx #3
0029E2  1               tasl:
0029E2  1  A9 00 48 B5          set_ax zp1,0
0029E6  1  13 28        
0029E8  1  0A                   asl a
0029E9  1  08 DD 20 02          tst_ax rASL,fASL,0
0029ED  1  D0 FE 68 49  
0029F1  1  30 DD 30 02  
0029F7  1  CA                   dex
0029F8  1  10 E8                bpl tasl
0029FA  1  A2 03                ldx #3
0029FC  1               tasl1:
0029FC  1  A9 FF 48 B5          set_ax zp1,$ff
002A00  1  13 28        
002A02  1  0A                   asl a
002A03  1  08 DD 20 02          tst_ax rASL,fASL,$ff-fnzc
002A07  1  D0 FE 68 49  
002A0B  1  7C DD 30 02  
002A11  1  CA                   dex
002A12  1  10 E8                bpl tasl1
002A14  1               
002A14  1  A2 03                ldx #3
002A16  1               tlsr:
002A16  1  A9 00 48 B5          set_ax zp1,0
002A1A  1  13 28        
002A1C  1  4A                   lsr a
002A1D  1  08 DD 28 02          tst_ax rLSR,fLSR,0
002A21  1  D0 FE 68 49  
002A25  1  30 DD 38 02  
002A2B  1  CA                   dex
002A2C  1  10 E8                bpl tlsr
002A2E  1  A2 03                ldx #3
002A30  1               tlsr1:
002A30  1  A9 FF 48 B5          set_ax zp1,$ff
002A34  1  13 28        
002A36  1  4A                   lsr a
002A37  1  08 DD 28 02          tst_ax rLSR,fLSR,$ff-fnzc
002A3B  1  D0 FE 68 49  
002A3F  1  7C DD 38 02  
002A45  1  CA                   dex
002A46  1  10 E8                bpl tlsr1
002A48  1               
002A48  1  A2 03                ldx #3
002A4A  1               trol:
002A4A  1  A9 00 48 B5          set_ax zp1,0
002A4E  1  13 28        
002A50  1  2A                   rol a
002A51  1  08 DD 20 02          tst_ax rROL,fROL,0
002A55  1  D0 FE 68 49  
002A59  1  30 DD 30 02  
002A5F  1  CA                   dex
002A60  1  10 E8                bpl trol
002A62  1  A2 03                ldx #3
002A64  1               trol1:
002A64  1  A9 FE 48 B5          set_ax zp1,$ff-fc
002A68  1  13 28        
002A6A  1  2A                   rol a
002A6B  1  08 DD 20 02          tst_ax rROL,fROL,$ff-fnzc
002A6F  1  D0 FE 68 49  
002A73  1  7C DD 30 02  
002A79  1  CA                   dex
002A7A  1  10 E8                bpl trol1
002A7C  1               
002A7C  1  A2 03                ldx #3
002A7E  1               trolc:
002A7E  1  A9 01 48 B5          set_ax zp1,fc
002A82  1  13 28        
002A84  1  2A                   rol a
002A85  1  08 DD 24 02          tst_ax rROLc,fROLc,0
002A89  1  D0 FE 68 49  
002A8D  1  30 DD 34 02  
002A93  1  CA                   dex
002A94  1  10 E8                bpl trolc
002A96  1  A2 03                ldx #3
002A98  1               trolc1:
002A98  1  A9 FF 48 B5          set_ax zp1,$ff
002A9C  1  13 28        
002A9E  1  2A                   rol a
002A9F  1  08 DD 24 02          tst_ax rROLc,fROLc,$ff-fnzc
002AA3  1  D0 FE 68 49  
002AA7  1  7C DD 34 02  
002AAD  1  CA                   dex
002AAE  1  10 E8                bpl trolc1
002AB0  1               
002AB0  1  A2 03                ldx #3
002AB2  1               tror:
002AB2  1  A9 00 48 B5          set_ax zp1,0
002AB6  1  13 28        
002AB8  1  6A                   ror a
002AB9  1  08 DD 28 02          tst_ax rROR,fROR,0
002ABD  1  D0 FE 68 49  
002AC1  1  30 DD 38 02  
002AC7  1  CA                   dex
002AC8  1  10 E8                bpl tror
002ACA  1  A2 03                ldx #3
002ACC  1               tror1:
002ACC  1  A9 FE 48 B5          set_ax zp1,$ff-fc
002AD0  1  13 28        
002AD2  1  6A                   ror a
002AD3  1  08 DD 28 02          tst_ax rROR,fROR,$ff-fnzc
002AD7  1  D0 FE 68 49  
002ADB  1  7C DD 38 02  
002AE1  1  CA                   dex
002AE2  1  10 E8                bpl tror1
002AE4  1               
002AE4  1  A2 03                ldx #3
002AE6  1               trorc:
002AE6  1  A9 01 48 B5          set_ax zp1,fc
002AEA  1  13 28        
002AEC  1  6A                   ror a
002AED  1  08 DD 2C 02          tst_ax rRORc,fRORc,0
002AF1  1  D0 FE 68 49  
002AF5  1  30 DD 3C 02  
002AFB  1  CA                   dex
002AFC  1  10 E8                bpl trorc
002AFE  1  A2 03                ldx #3
002B00  1               trorc1:
002B00  1  A9 FF 48 B5          set_ax zp1,$ff
002B04  1  13 28        
002B06  1  6A                   ror a
002B07  1  08 DD 2C 02          tst_ax rRORc,fRORc,$ff-fnzc
002B0B  1  D0 FE 68 49  
002B0F  1  7C DD 3C 02  
002B15  1  CA                   dex
002B16  1  10 E8                bpl trorc1
002B18  1  AD 00 02 C9          next_test
002B1C  1  1D D0 FE A9  
002B20  1  1E 8D 00 02  
002B61  1               
002B61  1               ; shifts - zeropage
002B61  1  A2 03                ldx #3
002B63  1               tasl2:
002B63  1  A9 00 48 B5          set_z zp1,0
002B67  1  13 85 0C 28  
002B6B  1  06 0C                asl zpt
002B6D  1  08 A5 0C DD          tst_z rASL,fASL,0
002B71  1  20 02 D0 FE  
002B75  1  68 49 30 DD  
002B7D  1  CA                   dex
002B7E  1  10 E3                bpl tasl2
002B80  1  A2 03                ldx #3
002B82  1               tasl3:
002B82  1  A9 FF 48 B5          set_z zp1,$ff
002B86  1  13 85 0C 28  
002B8A  1  06 0C                asl zpt
002B8C  1  08 A5 0C DD          tst_z rASL,fASL,$ff-fnzc
002B90  1  20 02 D0 FE  
002B94  1  68 49 7C DD  
002B9C  1  CA                   dex
002B9D  1  10 E3                bpl tasl3
002B9F  1               
002B9F  1  A2 03                ldx #3
002BA1  1               tlsr2:
002BA1  1  A9 00 48 B5          set_z zp1,0
002BA5  1  13 85 0C 28  
002BA9  1  46 0C                lsr zpt
002BAB  1  08 A5 0C DD          tst_z rLSR,fLSR,0
002BAF  1  28 02 D0 FE  
002BB3  1  68 49 30 DD  
002BBB  1  CA                   dex
002BBC  1  10 E3                bpl tlsr2
002BBE  1  A2 03                ldx #3
002BC0  1               tlsr3:
002BC0  1  A9 FF 48 B5          set_z zp1,$ff
002BC4  1  13 85 0C 28  
002BC8  1  46 0C                lsr zpt
002BCA  1  08 A5 0C DD          tst_z rLSR,fLSR,$ff-fnzc
002BCE  1  28 02 D0 FE  
002BD2  1  68 49 7C DD  
002BDA  1  CA                   dex
002BDB  1  10 E3                bpl tlsr3
002BDD  1               
002BDD  1  A2 03                ldx #3
002BDF  1               trol2:
002BDF  1  A9 00 48 B5          set_z zp1,0
002BE3  1  13 85 0C 28  
002BE7  1  26 0C                rol zpt
002BE9  1  08 A5 0C DD          tst_z rROL,fROL,0
002BED  1  20 02 D0 FE  
002BF1  1  68 49 30 DD  
002BF9  1  CA                   dex
002BFA  1  10 E3                bpl trol2
002BFC  1  A2 03                ldx #3
002BFE  1               trol3:
002BFE  1  A9 FE 48 B5          set_z zp1,$ff-fc
002C02  1  13 85 0C 28  
002C06  1  26 0C                rol zpt
002C08  1  08 A5 0C DD          tst_z rROL,fROL,$ff-fnzc
002C0C  1  20 02 D0 FE  
002C10  1  68 49 7C DD  
002C18  1  CA                   dex
002C19  1  10 E3                bpl trol3
002C1B  1               
002C1B  1  A2 03                ldx #3
002C1D  1               trolc2:
002C1D  1  A9 01 48 B5          set_z zp1,fc
002C21  1  13 85 0C 28  
002C25  1  26 0C                rol zpt
002C27  1  08 A5 0C DD          tst_z rROLc,fROLc,0
002C2B  1  24 02 D0 FE  
002C2F  1  68 49 30 DD  
002C37  1  CA                   dex
002C38  1  10 E3                bpl trolc2
002C3A  1  A2 03                ldx #3
002C3C  1               trolc3:
002C3C  1  A9 FF 48 B5          set_z zp1,$ff
002C40  1  13 85 0C 28  
002C44  1  26 0C                rol zpt
002C46  1  08 A5 0C DD          tst_z rROLc,fROLc,$ff-fnzc
002C4A  1  24 02 D0 FE  
002C4E  1  68 49 7C DD  
002C56  1  CA                   dex
002C57  1  10 E3                bpl trolc3
002C59  1               
002C59  1  A2 03                ldx #3
002C5B  1               tror2:
002C5B  1  A9 00 48 B5          set_z zp1,0
002C5F  1  13 85 0C 28  
002C63  1  66 0C                ror zpt
002C65  1  08 A5 0C DD          tst_z rROR,fROR,0
002C69  1  28 02 D0 FE  
002C6D  1  68 49 30 DD  
002C75  1  CA                   dex
002C76  1  10 E3                bpl tror2
002C78  1  A2 03                ldx #3
002C7A  1               tror3:
002C7A  1  A9 FE 48 B5          set_z zp1,$ff-fc
002C7E  1  13 85 0C 28  
002C82  1  66 0C                ror zpt
002C84  1  08 A5 0C DD          tst_z rROR,fROR,$ff-fnzc
002C88  1  28 02 D0 FE  
002C8C  1  68 49 7C DD  
002C94  1  CA                   dex
002C95  1  10 E3                bpl tror3
002C97  1               
002C97  1  A2 03                ldx #3
002C99  1               trorc2:
002C99  1  A9 01 48 B5          set_z zp1,fc
002C9D  1  13 85 0C 28  
002CA1  1  66 0C                ror zpt
002CA3  1  08 A5 0C DD          tst_z rRORc,fRORc,0
002CA7  1  2C 02 D0 FE  
002CAB  1  68 49 30 DD  
002CB3  1  CA                   dex
002CB4  1  10 E3                bpl trorc2
002CB6  1  A2 03                ldx #3
002CB8  1               trorc3:
002CB8  1  A9 FF 48 B5          set_z zp1,$ff
002CBC  1  13 85 0C 28  
002CC0  1  66 0C                ror zpt
002CC2  1  08 A5 0C DD          tst_z rRORc,fRORc,$ff-fnzc
002CC6  1  2C 02 D0 FE  
002CCA  1  68 49 7C DD  
002CD2  1  CA                   dex
002CD3  1  10 E3                bpl trorc3
002CD5  1  AD 00 02 C9          next_test
002CD9  1  1E D0 FE A9  
002CDD  1  1F 8D 00 02  
002D1E  1               
002D1E  1               ; shifts - absolute
002D1E  1  A2 03                ldx #3
002D20  1               tasl4:
002D20  1  A9 00 48 B5          set_abs zp1,0
002D24  1  13 8D 03 02  
002D28  1  28           
002D29  1  0E 03 02             asl abst
002D2C  1  08 AD 03 02          tst_abs rASL,fASL,0
002D30  1  DD 20 02 D0  
002D34  1  FE 68 49 30  
002D3D  1  CA                   dex
002D3E  1  10 E0                bpl tasl4
002D40  1  A2 03                ldx #3
002D42  1               tasl5:
002D42  1  A9 FF 48 B5          set_abs zp1,$ff
002D46  1  13 8D 03 02  
002D4A  1  28           
002D4B  1  0E 03 02             asl abst
002D4E  1  08 AD 03 02          tst_abs rASL,fASL,$ff-fnzc
002D52  1  DD 20 02 D0  
002D56  1  FE 68 49 7C  
002D5F  1  CA                   dex
002D60  1  10 E0                bpl tasl5
002D62  1               
002D62  1  A2 03                ldx #3
002D64  1               tlsr4:
002D64  1  A9 00 48 B5          set_abs zp1,0
002D68  1  13 8D 03 02  
002D6C  1  28           
002D6D  1  4E 03 02             lsr abst
002D70  1  08 AD 03 02          tst_abs rLSR,fLSR,0
002D74  1  DD 28 02 D0  
002D78  1  FE 68 49 30  
002D81  1  CA                   dex
002D82  1  10 E0                bpl tlsr4
002D84  1  A2 03                ldx #3
002D86  1               tlsr5:
002D86  1  A9 FF 48 B5          set_abs zp1,$ff
002D8A  1  13 8D 03 02  
002D8E  1  28           
002D8F  1  4E 03 02             lsr abst
002D92  1  08 AD 03 02          tst_abs rLSR,fLSR,$ff-fnzc
002D96  1  DD 28 02 D0  
002D9A  1  FE 68 49 7C  
002DA3  1  CA                   dex
002DA4  1  10 E0                bpl tlsr5
002DA6  1               
002DA6  1  A2 03                ldx #3
002DA8  1               trol4:
002DA8  1  A9 00 48 B5          set_abs zp1,0
002DAC  1  13 8D 03 02  
002DB0  1  28           
002DB1  1  2E 03 02             rol abst
002DB4  1  08 AD 03 02          tst_abs rROL,fROL,0
002DB8  1  DD 20 02 D0  
002DBC  1  FE 68 49 30  
002DC5  1  CA                   dex
002DC6  1  10 E0                bpl trol4
002DC8  1  A2 03                ldx #3
002DCA  1               trol5:
002DCA  1  A9 FE 48 B5          set_abs zp1,$ff-fc
002DCE  1  13 8D 03 02  
002DD2  1  28           
002DD3  1  2E 03 02             rol abst
002DD6  1  08 AD 03 02          tst_abs rROL,fROL,$ff-fnzc
002DDA  1  DD 20 02 D0  
002DDE  1  FE 68 49 7C  
002DE7  1  CA                   dex
002DE8  1  10 E0                bpl trol5
002DEA  1               
002DEA  1  A2 03                ldx #3
002DEC  1               trolc4:
002DEC  1  A9 01 48 B5          set_abs zp1,fc
002DF0  1  13 8D 03 02  
002DF4  1  28           
002DF5  1  2E 03 02             rol abst
002DF8  1  08 AD 03 02          tst_abs rROLc,fROLc,0
002DFC  1  DD 24 02 D0  
002E00  1  FE 68 49 30  
002E09  1  CA                   dex
002E0A  1  10 E0                bpl trolc4
002E0C  1  A2 03                ldx #3
002E0E  1               trolc5:
002E0E  1  A9 FF 48 B5          set_abs zp1,$ff
002E12  1  13 8D 03 02  
002E16  1  28           
002E17  1  2E 03 02             rol abst
002E1A  1  08 AD 03 02          tst_abs rROLc,fROLc,$ff-fnzc
002E1E  1  DD 24 02 D0  
002E22  1  FE 68 49 7C  
002E2B  1  CA                   dex
002E2C  1  10 E0                bpl trolc5
002E2E  1               
002E2E  1  A2 03                ldx #3
002E30  1               tror4:
002E30  1  A9 00 48 B5          set_abs zp1,0
002E34  1  13 8D 03 02  
002E38  1  28           
002E39  1  6E 03 02             ror abst
002E3C  1  08 AD 03 02          tst_abs rROR,fROR,0
002E40  1  DD 28 02 D0  
002E44  1  FE 68 49 30  
002E4D  1  CA                   dex
002E4E  1  10 E0                bpl tror4
002E50  1  A2 03                ldx #3
002E52  1               tror5:
002E52  1  A9 FE 48 B5          set_abs zp1,$ff-fc
002E56  1  13 8D 03 02  
002E5A  1  28           
002E5B  1  6E 03 02             ror abst
002E5E  1  08 AD 03 02          tst_abs rROR,fROR,$ff-fnzc
002E62  1  DD 28 02 D0  
002E66  1  FE 68 49 7C  
002E6F  1  CA                   dex
002E70  1  10 E0                bpl tror5
002E72  1               
002E72  1  A2 03                ldx #3
002E74  1               trorc4:
002E74  1  A9 01 48 B5          set_abs zp1,fc
002E78  1  13 8D 03 02  
002E7C  1  28           
002E7D  1  6E 03 02             ror abst
002E80  1  08 AD 03 02          tst_abs rRORc,fRORc,0
002E84  1  DD 2C 02 D0  
002E88  1  FE 68 49 30  
002E91  1  CA                   dex
002E92  1  10 E0                bpl trorc4
002E94  1  A2 03                ldx #3
002E96  1               trorc5:
002E96  1  A9 FF 48 B5          set_abs zp1,$ff
002E9A  1  13 8D 03 02  
002E9E  1  28           
002E9F  1  6E 03 02             ror abst
002EA2  1  08 AD 03 02          tst_abs rRORc,fRORc,$ff-fnzc
002EA6  1  DD 2C 02 D0  
002EAA  1  FE 68 49 7C  
002EB3  1  CA                   dex
002EB4  1  10 E0                bpl trorc5
002EB6  1  AD 00 02 C9          next_test
002EBA  1  1F D0 FE A9  
002EBE  1  20 8D 00 02  
002EFF  1               
002EFF  1               ; shifts - zp indexed
002EFF  1  A2 03                ldx #3
002F01  1               tasl6:
002F01  1  A9 00 48 B5          set_zx zp1,0
002F05  1  13 95 0C 28  
002F09  1  16 0C                asl zpt,x
002F0B  1  08 B5 0C DD          tst_zx rASL,fASL,0
002F0F  1  20 02 D0 FE  
002F13  1  68 49 30 DD  
002F1B  1  CA                   dex
002F1C  1  10 E3                bpl tasl6
002F1E  1  A2 03                ldx #3
002F20  1               tasl7:
002F20  1  A9 FF 48 B5          set_zx zp1,$ff
002F24  1  13 95 0C 28  
002F28  1  16 0C                asl zpt,x
002F2A  1  08 B5 0C DD          tst_zx rASL,fASL,$ff-fnzc
002F2E  1  20 02 D0 FE  
002F32  1  68 49 7C DD  
002F3A  1  CA                   dex
002F3B  1  10 E3                bpl tasl7
002F3D  1               
002F3D  1  A2 03                ldx #3
002F3F  1               tlsr6:
002F3F  1  A9 00 48 B5          set_zx zp1,0
002F43  1  13 95 0C 28  
002F47  1  56 0C                lsr zpt,x
002F49  1  08 B5 0C DD          tst_zx rLSR,fLSR,0
002F4D  1  28 02 D0 FE  
002F51  1  68 49 30 DD  
002F59  1  CA                   dex
002F5A  1  10 E3                bpl tlsr6
002F5C  1  A2 03                ldx #3
002F5E  1               tlsr7:
002F5E  1  A9 FF 48 B5          set_zx zp1,$ff
002F62  1  13 95 0C 28  
002F66  1  56 0C                lsr zpt,x
002F68  1  08 B5 0C DD          tst_zx rLSR,fLSR,$ff-fnzc
002F6C  1  28 02 D0 FE  
002F70  1  68 49 7C DD  
002F78  1  CA                   dex
002F79  1  10 E3                bpl tlsr7
002F7B  1               
002F7B  1  A2 03                ldx #3
002F7D  1               trol6:
002F7D  1  A9 00 48 B5          set_zx zp1,0
002F81  1  13 95 0C 28  
002F85  1  36 0C                rol zpt,x
002F87  1  08 B5 0C DD          tst_zx rROL,fROL,0
002F8B  1  20 02 D0 FE  
002F8F  1  68 49 30 DD  
002F97  1  CA                   dex
002F98  1  10 E3                bpl trol6
002F9A  1  A2 03                ldx #3
002F9C  1               trol7:
002F9C  1  A9 FE 48 B5          set_zx zp1,$ff-fc
002FA0  1  13 95 0C 28  
002FA4  1  36 0C                rol zpt,x
002FA6  1  08 B5 0C DD          tst_zx rROL,fROL,$ff-fnzc
002FAA  1  20 02 D0 FE  
002FAE  1  68 49 7C DD  
002FB6  1  CA                   dex
002FB7  1  10 E3                bpl trol7
002FB9  1               
002FB9  1  A2 03                ldx #3
002FBB  1               trolc6:
002FBB  1  A9 01 48 B5          set_zx zp1,fc
002FBF  1  13 95 0C 28  
002FC3  1  36 0C                rol zpt,x
002FC5  1  08 B5 0C DD          tst_zx rROLc,fROLc,0
002FC9  1  24 02 D0 FE  
002FCD  1  68 49 30 DD  
002FD5  1  CA                   dex
002FD6  1  10 E3                bpl trolc6
002FD8  1  A2 03                ldx #3
002FDA  1               trolc7:
002FDA  1  A9 FF 48 B5          set_zx zp1,$ff
002FDE  1  13 95 0C 28  
002FE2  1  36 0C                rol zpt,x
002FE4  1  08 B5 0C DD          tst_zx rROLc,fROLc,$ff-fnzc
002FE8  1  24 02 D0 FE  
002FEC  1  68 49 7C DD  
002FF4  1  CA                   dex
002FF5  1  10 E3                bpl trolc7
002FF7  1               
002FF7  1  A2 03                ldx #3
002FF9  1               tror6:
002FF9  1  A9 00 48 B5          set_zx zp1,0
002FFD  1  13 95 0C 28  
003001  1  76 0C                ror zpt,x
003003  1  08 B5 0C DD          tst_zx rROR,fROR,0
003007  1  28 02 D0 FE  
00300B  1  68 49 30 DD  
003013  1  CA                   dex
003014  1  10 E3                bpl tror6
003016  1  A2 03                ldx #3
003018  1               tror7:
003018  1  A9 FE 48 B5          set_zx zp1,$ff-fc
00301C  1  13 95 0C 28  
003020  1  76 0C                ror zpt,x
003022  1  08 B5 0C DD          tst_zx rROR,fROR,$ff-fnzc
003026  1  28 02 D0 FE  
00302A  1  68 49 7C DD  
003032  1  CA                   dex
003033  1  10 E3                bpl tror7
003035  1               
003035  1  A2 03                ldx #3
003037  1               trorc6:
003037  1  A9 01 48 B5          set_zx zp1,fc
00303B  1  13 95 0C 28  
00303F  1  76 0C                ror zpt,x
003041  1  08 B5 0C DD          tst_zx rRORc,fRORc,0
003045  1  2C 02 D0 FE  
003049  1  68 49 30 DD  
003051  1  CA                   dex
003052  1  10 E3                bpl trorc6
003054  1  A2 03                ldx #3
003056  1               trorc7:
003056  1  A9 FF 48 B5          set_zx zp1,$ff
00305A  1  13 95 0C 28  
00305E  1  76 0C                ror zpt,x
003060  1  08 B5 0C DD          tst_zx rRORc,fRORc,$ff-fnzc
003064  1  2C 02 D0 FE  
003068  1  68 49 7C DD  
003070  1  CA                   dex
003071  1  10 E3                bpl trorc7
003073  1  AD 00 02 C9          next_test
003077  1  20 D0 FE A9  
00307B  1  21 8D 00 02  
0030BC  1               
0030BC  1               ; shifts - abs indexed
0030BC  1  A2 03                ldx #3
0030BE  1               tasl8:
0030BE  1  A9 00 48 B5          set_absx zp1,0
0030C2  1  13 9D 03 02  
0030C6  1  28           
0030C7  1  1E 03 02             asl abst,x
0030CA  1  08 BD 03 02          tst_absx rASL,fASL,0
0030CE  1  DD 20 02 D0  
0030D2  1  FE 68 49 30  
0030DB  1  CA                   dex
0030DC  1  10 E0                bpl tasl8
0030DE  1  A2 03                ldx #3
0030E0  1               tasl9:
0030E0  1  A9 FF 48 B5          set_absx zp1,$ff
0030E4  1  13 9D 03 02  
0030E8  1  28           
0030E9  1  1E 03 02             asl abst,x
0030EC  1  08 BD 03 02          tst_absx rASL,fASL,$ff-fnzc
0030F0  1  DD 20 02 D0  
0030F4  1  FE 68 49 7C  
0030FD  1  CA                   dex
0030FE  1  10 E0                bpl tasl9
003100  1               
003100  1  A2 03                ldx #3
003102  1               tlsr8:
003102  1  A9 00 48 B5          set_absx zp1,0
003106  1  13 9D 03 02  
00310A  1  28           
00310B  1  5E 03 02             lsr abst,x
00310E  1  08 BD 03 02          tst_absx rLSR,fLSR,0
003112  1  DD 28 02 D0  
003116  1  FE 68 49 30  
00311F  1  CA                   dex
003120  1  10 E0                bpl tlsr8
003122  1  A2 03                ldx #3
003124  1               tlsr9:
003124  1  A9 FF 48 B5          set_absx zp1,$ff
003128  1  13 9D 03 02  
00312C  1  28           
00312D  1  5E 03 02             lsr abst,x
003130  1  08 BD 03 02          tst_absx rLSR,fLSR,$ff-fnzc
003134  1  DD 28 02 D0  
003138  1  FE 68 49 7C  
003141  1  CA                   dex
003142  1  10 E0                bpl tlsr9
003144  1               
003144  1  A2 03                ldx #3
003146  1               trol8:
003146  1  A9 00 48 B5          set_absx zp1,0
00314A  1  13 9D 03 02  
00314E  1  28           
00314F  1  3E 03 02             rol abst,x
003152  1  08 BD 03 02          tst_absx rROL,fROL,0
003156  1  DD 20 02 D0  
00315A  1  FE 68 49 30  
003163  1  CA                   dex
003164  1  10 E0                bpl trol8
003166  1  A2 03                ldx #3
003168  1               trol9:
003168  1  A9 FE 48 B5          set_absx zp1,$ff-fc
00316C  1  13 9D 03 02  
003170  1  28           
003171  1  3E 03 02             rol abst,x
003174  1  08 BD 03 02          tst_absx rROL,fROL,$ff-fnzc
003178  1  DD 20 02 D0  
00317C  1  FE 68 49 7C  
003185  1  CA                   dex
003186  1  10 E0                bpl trol9
003188  1               
003188  1  A2 03                ldx #3
00318A  1               trolc8:
00318A  1  A9 01 48 B5          set_absx zp1,fc
00318E  1  13 9D 03 02  
003192  1  28           
003193  1  3E 03 02             rol abst,x
003196  1  08 BD 03 02          tst_absx rROLc,fROLc,0
00319A  1  DD 24 02 D0  
00319E  1  FE 68 49 30  
0031A7  1  CA                   dex
0031A8  1  10 E0                bpl trolc8
0031AA  1  A2 03                ldx #3
0031AC  1               trolc9:
0031AC  1  A9 FF 48 B5          set_absx zp1,$ff
0031B0  1  13 9D 03 02  
0031B4  1  28           
0031B5  1  3E 03 02             rol abst,x
0031B8  1  08 BD 03 02          tst_absx rROLc,fROLc,$ff-fnzc
0031BC  1  DD 24 02 D0  
0031C0  1  FE 68 49 7C  
0031C9  1  CA                   dex
0031CA  1  10 E0                bpl trolc9
0031CC  1               
0031CC  1  A2 03                ldx #3
0031CE  1               tror8:
0031CE  1  A9 00 48 B5          set_absx zp1,0
0031D2  1  13 9D 03 02  
0031D6  1  28           
0031D7  1  7E 03 02             ror abst,x
0031DA  1  08 BD 03 02          tst_absx rROR,fROR,0
0031DE  1  DD 28 02 D0  
0031E2  1  FE 68 49 30  
0031EB  1  CA                   dex
0031EC  1  10 E0                bpl tror8
0031EE  1  A2 03                ldx #3
0031F0  1               tror9:
0031F0  1  A9 FE 48 B5          set_absx zp1,$ff-fc
0031F4  1  13 9D 03 02  
0031F8  1  28           
0031F9  1  7E 03 02             ror abst,x
0031FC  1  08 BD 03 02          tst_absx rROR,fROR,$ff-fnzc
003200  1  DD 28 02 D0  
003204  1  FE 68 49 7C  
00320D  1  CA                   dex
00320E  1  10 E0                bpl tror9
003210  1               
003210  1  A2 03                ldx #3
003212  1               trorc8:
003212  1  A9 01 48 B5          set_absx zp1,fc
003216  1  13 9D 03 02  
00321A  1  28           
00321B  1  7E 03 02             ror abst,x
00321E  1  08 BD 03 02          tst_absx rRORc,fRORc,0
003222  1  DD 2C 02 D0  
003226  1  FE 68 49 30  
00322F  1  CA                   dex
003230  1  10 E0                bpl trorc8
003232  1  A2 03                ldx #3
003234  1               trorc9:
003234  1  A9 FF 48 B5          set_absx zp1,$ff
003238  1  13 9D 03 02  
00323C  1  28           
00323D  1  7E 03 02             ror abst,x
003240  1  08 BD 03 02          tst_absx rRORc,fRORc,$ff-fnzc
003244  1  DD 2C 02 D0  
003248  1  FE 68 49 7C  
003251  1  CA                   dex
003252  1  10 E0                bpl trorc9
003254  1  AD 00 02 C9          next_test
003258  1  21 D0 FE A9  
00325C  1  22 8D 00 02  
00329D  1               
00329D  1               ; testing memory increment/decrement - INC DEC all addressing modes
00329D  1               ; zeropage
00329D  1  A2 00                ldx #0
00329F  1  A9 7E                lda #$7e
0032A1  1  85 0C                sta zpt
0032A3  1               tinc:
0032A3  1  A9 00 48 28          set_stat 0
0032A7  1  E6 0C                inc zpt
0032A9  1  08 A5 0C DD          tst_z rINC,fINC,0
0032AD  1  40 02 D0 FE  
0032B1  1  68 49 30 DD  
0032B9  1  E8                   inx
0032BA  1  E0 02                cpx #2
0032BC  1  D0 04                bne tinc1
0032BE  1  A9 FE                lda #$fe
0032C0  1  85 0C                sta zpt
0032C2  1  E0 05        tinc1:  cpx #5
0032C4  1  D0 DD                bne tinc
0032C6  1  CA                   dex
0032C7  1  E6 0C                inc zpt
0032C9  1               tdec:
0032C9  1  A9 00 48 28          set_stat 0
0032CD  1  C6 0C                dec zpt
0032CF  1  08 A5 0C DD          tst_z rINC,fINC,0
0032D3  1  40 02 D0 FE  
0032D7  1  68 49 30 DD  
0032DF  1  CA                   dex
0032E0  1  30 0A                bmi tdec1
0032E2  1  E0 01                cpx #1
0032E4  1  D0 E3                bne tdec
0032E6  1  A9 81                lda #$81
0032E8  1  85 0C                sta zpt
0032EA  1  D0 DD                bne tdec
0032EC  1               tdec1:
0032EC  1  A2 00                ldx #0
0032EE  1  A9 7E                lda #$7e
0032F0  1  85 0C                sta zpt
0032F2  1               tinc10:
0032F2  1  A9 FF 48 28          set_stat $ff
0032F6  1  E6 0C                inc zpt
0032F8  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
0032FC  1  40 02 D0 FE  
003300  1  68 49 7D DD  
003308  1  E8                   inx
003309  1  E0 02                cpx #2
00330B  1  D0 04                bne tinc11
00330D  1  A9 FE                lda #$fe
00330F  1  85 0C                sta zpt
003311  1  E0 05        tinc11: cpx #5
003313  1  D0 DD                bne tinc10
003315  1  CA                   dex
003316  1  E6 0C                inc zpt
003318  1               tdec10:
003318  1  A9 FF 48 28          set_stat $ff
00331C  1  C6 0C                dec zpt
00331E  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
003322  1  40 02 D0 FE  
003326  1  68 49 7D DD  
00332E  1  CA                   dex
00332F  1  30 0A                bmi tdec11
003331  1  E0 01                cpx #1
003333  1  D0 E3                bne tdec10
003335  1  A9 81                lda #$81
003337  1  85 0C                sta zpt
003339  1  D0 DD                bne tdec10
00333B  1               tdec11:
00333B  1  AD 00 02 C9          next_test
00333F  1  22 D0 FE A9  
003343  1  23 8D 00 02  
003384  1               
003384  1               ; absolute memory
003384  1  A2 00                ldx #0
003386  1  A9 7E                lda #$7e
003388  1  8D 03 02             sta abst
00338B  1               tinc2:
00338B  1  A9 00 48 28          set_stat 0
00338F  1  EE 03 02             inc abst
003392  1  08 AD 03 02          tst_abs rINC,fINC,0
003396  1  DD 40 02 D0  
00339A  1  FE 68 49 30  
0033A3  1  E8                   inx
0033A4  1  E0 02                cpx #2
0033A6  1  D0 05                bne tinc3
0033A8  1  A9 FE                lda #$fe
0033AA  1  8D 03 02             sta abst
0033AD  1  E0 05        tinc3:  cpx #5
0033AF  1  D0 DA                bne tinc2
0033B1  1  CA                   dex
0033B2  1  EE 03 02             inc abst
0033B5  1               tdec2:
0033B5  1  A9 00 48 28          set_stat 0
0033B9  1  CE 03 02             dec abst
0033BC  1  08 AD 03 02          tst_abs rINC,fINC,0
0033C0  1  DD 40 02 D0  
0033C4  1  FE 68 49 30  
0033CD  1  CA                   dex
0033CE  1  30 0B                bmi tdec3
0033D0  1  E0 01                cpx #1
0033D2  1  D0 E1                bne tdec2
0033D4  1  A9 81                lda #$81
0033D6  1  8D 03 02             sta abst
0033D9  1  D0 DA                bne tdec2
0033DB  1               tdec3:
0033DB  1  A2 00                ldx #0
0033DD  1  A9 7E                lda #$7e
0033DF  1  8D 03 02             sta abst
0033E2  1               tinc12:
0033E2  1  A9 FF 48 28          set_stat $ff
0033E6  1  EE 03 02             inc abst
0033E9  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
0033ED  1  DD 40 02 D0  
0033F1  1  FE 68 49 7D  
0033FA  1  E8                   inx
0033FB  1  E0 02                cpx #2
0033FD  1  D0 05                bne tinc13
0033FF  1  A9 FE                lda #$fe
003401  1  8D 03 02             sta abst
003404  1  E0 05        tinc13:  cpx #5
003406  1  D0 DA                bne tinc12
003408  1  CA                   dex
003409  1  EE 03 02             inc abst
00340C  1               tdec12:
00340C  1  A9 FF 48 28          set_stat $ff
003410  1  CE 03 02             dec abst
003413  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
003417  1  DD 40 02 D0  
00341B  1  FE 68 49 7D  
003424  1  CA                   dex
003425  1  30 0B                bmi tdec13
003427  1  E0 01                cpx #1
003429  1  D0 E1                bne tdec12
00342B  1  A9 81                lda #$81
00342D  1  8D 03 02             sta abst
003430  1  D0 DA                bne tdec12
003432  1               tdec13:
003432  1  AD 00 02 C9          next_test
003436  1  23 D0 FE A9  
00343A  1  24 8D 00 02  
00347B  1               
00347B  1               ; zeropage indexed
00347B  1  A2 00                ldx #0
00347D  1  A9 7E                lda #$7e
00347F  1  95 0C        tinc4:  sta zpt,x
003481  1  A9 00 48 28          set_stat 0
003485  1  F6 0C                inc zpt,x
003487  1  08 B5 0C DD          tst_zx rINC,fINC,0
00348B  1  40 02 D0 FE  
00348F  1  68 49 30 DD  
003497  1  B5 0C                lda zpt,x
003499  1  E8                   inx
00349A  1  E0 02                cpx #2
00349C  1  D0 02                bne tinc5
00349E  1  A9 FE                lda #$fe
0034A0  1  E0 05        tinc5:  cpx #5
0034A2  1  D0 DB                bne tinc4
0034A4  1  CA                   dex
0034A5  1  A9 02                lda #2
0034A7  1  95 0C        tdec4:  sta zpt,x
0034A9  1  A9 00 48 28          set_stat 0
0034AD  1  D6 0C                dec zpt,x
0034AF  1  08 B5 0C DD          tst_zx rINC,fINC,0
0034B3  1  40 02 D0 FE  
0034B7  1  68 49 30 DD  
0034BF  1  B5 0C                lda zpt,x
0034C1  1  CA                   dex
0034C2  1  30 08                bmi tdec5
0034C4  1  E0 01                cpx #1
0034C6  1  D0 DF                bne tdec4
0034C8  1  A9 81                lda #$81
0034CA  1  D0 DB                bne tdec4
0034CC  1               tdec5:
0034CC  1  A2 00                ldx #0
0034CE  1  A9 7E                lda #$7e
0034D0  1  95 0C        tinc14: sta zpt,x
0034D2  1  A9 FF 48 28          set_stat $ff
0034D6  1  F6 0C                inc zpt,x
0034D8  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
0034DC  1  40 02 D0 FE  
0034E0  1  68 49 7D DD  
0034E8  1  B5 0C                lda zpt,x
0034EA  1  E8                   inx
0034EB  1  E0 02                cpx #2
0034ED  1  D0 02                bne tinc15
0034EF  1  A9 FE                lda #$fe
0034F1  1  E0 05        tinc15: cpx #5
0034F3  1  D0 DB                bne tinc14
0034F5  1  CA                   dex
0034F6  1  A9 02                lda #2
0034F8  1  95 0C        tdec14: sta zpt,x
0034FA  1  A9 FF 48 28          set_stat $ff
0034FE  1  D6 0C                dec zpt,x
003500  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
003504  1  40 02 D0 FE  
003508  1  68 49 7D DD  
003510  1  B5 0C                lda zpt,x
003512  1  CA                   dex
003513  1  30 08                bmi tdec15
003515  1  E0 01                cpx #1
003517  1  D0 DF                bne tdec14
003519  1  A9 81                lda #$81
00351B  1  D0 DB                bne tdec14
00351D  1               tdec15:
00351D  1  AD 00 02 C9          next_test
003521  1  24 D0 FE A9  
003525  1  25 8D 00 02  
003566  1               
003566  1               ; memory indexed
003566  1  A2 00                ldx #0
003568  1  A9 7E                lda #$7e
00356A  1  9D 03 02     tinc6:  sta abst,x
00356D  1  A9 00 48 28          set_stat 0
003571  1  FE 03 02             inc abst,x
003574  1  08 BD 03 02          tst_absx rINC,fINC,0
003578  1  DD 40 02 D0  
00357C  1  FE 68 49 30  
003585  1  BD 03 02             lda abst,x
003588  1  E8                   inx
003589  1  E0 02                cpx #2
00358B  1  D0 02                bne tinc7
00358D  1  A9 FE                lda #$fe
00358F  1  E0 05        tinc7:  cpx #5
003591  1  D0 D7                bne tinc6
003593  1  CA                   dex
003594  1  A9 02                lda #2
003596  1  9D 03 02     tdec6:  sta abst,x
003599  1  A9 00 48 28          set_stat 0
00359D  1  DE 03 02             dec abst,x
0035A0  1  08 BD 03 02          tst_absx rINC,fINC,0
0035A4  1  DD 40 02 D0  
0035A8  1  FE 68 49 30  
0035B1  1  BD 03 02             lda abst,x
0035B4  1  CA                   dex
0035B5  1  30 08                bmi tdec7
0035B7  1  E0 01                cpx #1
0035B9  1  D0 DB                bne tdec6
0035BB  1  A9 81                lda #$81
0035BD  1  D0 D7                bne tdec6
0035BF  1               tdec7:
0035BF  1  A2 00                ldx #0
0035C1  1  A9 7E                lda #$7e
0035C3  1  9D 03 02     tinc16: sta abst,x
0035C6  1  A9 FF 48 28          set_stat $ff
0035CA  1  FE 03 02             inc abst,x
0035CD  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
0035D1  1  DD 40 02 D0  
0035D5  1  FE 68 49 7D  
0035DE  1  BD 03 02             lda abst,x
0035E1  1  E8                   inx
0035E2  1  E0 02                cpx #2
0035E4  1  D0 02                bne tinc17
0035E6  1  A9 FE                lda #$fe
0035E8  1  E0 05        tinc17: cpx #5
0035EA  1  D0 D7                bne tinc16
0035EC  1  CA                   dex
0035ED  1  A9 02                lda #2
0035EF  1  9D 03 02     tdec16: sta abst,x
0035F2  1  A9 FF 48 28          set_stat $ff
0035F6  1  DE 03 02             dec abst,x
0035F9  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
0035FD  1  DD 40 02 D0  
003601  1  FE 68 49 7D  
00360A  1  BD 03 02             lda abst,x
00360D  1  CA                   dex
00360E  1  30 08                bmi tdec17
003610  1  E0 01                cpx #1
003612  1  D0 DB                bne tdec16
003614  1  A9 81                lda #$81
003616  1  D0 D7                bne tdec16
003618  1               tdec17:
003618  1  AD 00 02 C9          next_test
00361C  1  25 D0 FE A9  
003620  1  26 8D 00 02  
003661  1               
003661  1               ; testing logical instructions - AND EOR ORA all addressing modes
003661  1               ; AND
003661  1  A2 03                ldx #3          ;immediate
003663  1  B5 1C        tand:   lda zpAN,x
003665  1  8D 09 02             sta ex_andi+1   ;set AND # operand
003668  1  A9 00 48 BD          set_ax  absANa,0
00366C  1  5A 02 28     
00366F  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
003672  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003676  1  D0 FE 68 49  
00367A  1  30 DD 66 02  
003680  1  CA                   dex
003681  1  10 E0                bpl tand
003683  1  A2 03                ldx #3
003685  1  B5 1C        tand1:  lda zpAN,x
003687  1  8D 09 02             sta ex_andi+1   ;set AND # operand
00368A  1  A9 FF 48 BD          set_ax  absANa,$ff
00368E  1  5A 02 28     
003691  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
003694  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003698  1  D0 FE 68 49  
00369C  1  7D DD 66 02  
0036A2  1  CA                   dex
0036A3  1  10 E0                bpl tand1
0036A5  1               
0036A5  1  A2 03                ldx #3      ;zp
0036A7  1  B5 1C        tand2:  lda zpAN,x
0036A9  1  85 0C                sta zpt
0036AB  1  A9 00 48 BD          set_ax  absANa,0
0036AF  1  5A 02 28     
0036B2  1  25 0C                and zpt
0036B4  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0036B8  1  D0 FE 68 49  
0036BC  1  30 DD 66 02  
0036C2  1  CA                   dex
0036C3  1  10 E2                bpl tand2
0036C5  1  A2 03                ldx #3
0036C7  1  B5 1C        tand3:  lda zpAN,x
0036C9  1  85 0C                sta zpt
0036CB  1  A9 FF 48 BD          set_ax  absANa,$ff
0036CF  1  5A 02 28     
0036D2  1  25 0C                and zpt
0036D4  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0036D8  1  D0 FE 68 49  
0036DC  1  7D DD 66 02  
0036E2  1  CA                   dex
0036E3  1  10 E2                bpl tand3
0036E5  1               
0036E5  1  A2 03                ldx #3      ;abs
0036E7  1  B5 1C        tand4:  lda zpAN,x
0036E9  1  8D 03 02             sta abst
0036EC  1  A9 00 48 BD          set_ax  absANa,0
0036F0  1  5A 02 28     
0036F3  1  2D 03 02             and abst
0036F6  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0036FA  1  D0 FE 68 49  
0036FE  1  30 DD 66 02  
003704  1  CA                   dex
003705  1  10 E0                bpl tand4
003707  1  A2 03                ldx #3
003709  1  B5 1C        tand5:  lda zpAN,x
00370B  1  8D 03 02             sta abst
00370E  1  A9 FF 48 BD          set_ax  absANa,$ff
003712  1  5A 02 28     
003715  1  2D 03 02             and abst
003718  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00371C  1  D0 FE 68 49  
003720  1  7D DD 66 02  
003726  1  CA                   dex
003727  1  10 02                bpl tand6
003729  1               
003729  1  A2 03                ldx #3      ;zp,x
00372B  1               tand6:
00372B  1  A9 00 48 BD          set_ax  absANa,0
00372F  1  5A 02 28     
003732  1  35 1C                and zpAN,x
003734  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003738  1  D0 FE 68 49  
00373C  1  30 DD 66 02  
003742  1  CA                   dex
003743  1  10 E6                bpl tand6
003745  1  A2 03                ldx #3
003747  1               tand7:
003747  1  A9 FF 48 BD          set_ax  absANa,$ff
00374B  1  5A 02 28     
00374E  1  35 1C                and zpAN,x
003750  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003754  1  D0 FE 68 49  
003758  1  7D DD 66 02  
00375E  1  CA                   dex
00375F  1  10 E6                bpl tand7
003761  1               
003761  1  A2 03                ldx #3      ;abs,x
003763  1               tand8:
003763  1  A9 00 48 BD          set_ax  absANa,0
003767  1  5A 02 28     
00376A  1  3D 4E 02             and absAN,x
00376D  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003771  1  D0 FE 68 49  
003775  1  30 DD 66 02  
00377B  1  CA                   dex
00377C  1  10 E5                bpl tand8
00377E  1  A2 03                ldx #3
003780  1               tand9:
003780  1  A9 FF 48 BD          set_ax  absANa,$ff
003784  1  5A 02 28     
003787  1  3D 4E 02             and absAN,x
00378A  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00378E  1  D0 FE 68 49  
003792  1  7D DD 66 02  
003798  1  CA                   dex
003799  1  10 E5                bpl tand9
00379B  1               
00379B  1  A0 03                ldy #3      ;abs,y
00379D  1               tand10:
00379D  1  A9 00 48 B9          set_ay  absANa,0
0037A1  1  5A 02 28     
0037A4  1  39 4E 02             and absAN,y
0037A7  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0037AB  1  D0 FE 68 49  
0037AF  1  30 D9 66 02  
0037B5  1  88                   dey
0037B6  1  10 E5                bpl tand10
0037B8  1  A0 03                ldy #3
0037BA  1               tand11:
0037BA  1  A9 FF 48 B9          set_ay  absANa,$ff
0037BE  1  5A 02 28     
0037C1  1  39 4E 02             and absAN,y
0037C4  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0037C8  1  D0 FE 68 49  
0037CC  1  7D D9 66 02  
0037D2  1  88                   dey
0037D3  1  10 E5                bpl tand11
0037D5  1               
0037D5  1  A2 06                ldx #6      ;(zp,x)
0037D7  1  A0 03                ldy #3
0037D9  1               tand12:
0037D9  1  A9 00 48 B9          set_ay  absANa,0
0037DD  1  5A 02 28     
0037E0  1  21 3A                and (indAN,x)
0037E2  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0037E6  1  D0 FE 68 49  
0037EA  1  30 D9 66 02  
0037F0  1  CA                   dex
0037F1  1  CA                   dex
0037F2  1  88                   dey
0037F3  1  10 E4                bpl tand12
0037F5  1  A2 06                ldx #6
0037F7  1  A0 03                ldy #3
0037F9  1               tand13:
0037F9  1  A9 FF 48 B9          set_ay  absANa,$ff
0037FD  1  5A 02 28     
003800  1  21 3A                and (indAN,x)
003802  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003806  1  D0 FE 68 49  
00380A  1  7D D9 66 02  
003810  1  CA                   dex
003811  1  CA                   dex
003812  1  88                   dey
003813  1  10 E4                bpl tand13
003815  1               
003815  1  A0 03                ldy #3      ;(zp),y
003817  1               tand14:
003817  1  A9 00 48 B9          set_ay  absANa,0
00381B  1  5A 02 28     
00381E  1  31 3A                and (indAN),y
003820  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003824  1  D0 FE 68 49  
003828  1  30 D9 66 02  
00382E  1  88                   dey
00382F  1  10 E6                bpl tand14
003831  1  A0 03                ldy #3
003833  1               tand15:
003833  1  A9 FF 48 B9          set_ay  absANa,$ff
003837  1  5A 02 28     
00383A  1  31 3A                and (indAN),y
00383C  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003840  1  D0 FE 68 49  
003844  1  7D D9 66 02  
00384A  1  88                   dey
00384B  1  10 E6                bpl tand15
00384D  1  AD 00 02 C9          next_test
003851  1  26 D0 FE A9  
003855  1  27 8D 00 02  
003896  1               
003896  1               ; EOR
003896  1  A2 03                ldx #3          ;immediate - self modifying code
003898  1  B5 20        teor:   lda zpEO,x
00389A  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
00389D  1  A9 00 48 BD          set_ax  absEOa,0
0038A1  1  5E 02 28     
0038A4  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
0038A7  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0038AB  1  D0 FE 68 49  
0038AF  1  30 DD 66 02  
0038B5  1  CA                   dex
0038B6  1  10 E0                bpl teor
0038B8  1  A2 03                ldx #3
0038BA  1  B5 20        teor1:  lda zpEO,x
0038BC  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
0038BF  1  A9 FF 48 BD          set_ax  absEOa,$ff
0038C3  1  5E 02 28     
0038C6  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
0038C9  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0038CD  1  D0 FE 68 49  
0038D1  1  7D DD 66 02  
0038D7  1  CA                   dex
0038D8  1  10 E0                bpl teor1
0038DA  1               
0038DA  1  A2 03                ldx #3      ;zp
0038DC  1  B5 20        teor2:   lda zpEO,x
0038DE  1  85 0C                sta zpt
0038E0  1  A9 00 48 BD          set_ax  absEOa,0
0038E4  1  5E 02 28     
0038E7  1  45 0C                eor zpt
0038E9  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0038ED  1  D0 FE 68 49  
0038F1  1  30 DD 66 02  
0038F7  1  CA                   dex
0038F8  1  10 E2                bpl teor2
0038FA  1  A2 03                ldx #3
0038FC  1  B5 20        teor3:  lda zpEO,x
0038FE  1  85 0C                sta zpt
003900  1  A9 FF 48 BD          set_ax  absEOa,$ff
003904  1  5E 02 28     
003907  1  45 0C                eor zpt
003909  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00390D  1  D0 FE 68 49  
003911  1  7D DD 66 02  
003917  1  CA                   dex
003918  1  10 E2                bpl teor3
00391A  1               
00391A  1  A2 03                ldx #3      ;abs
00391C  1  B5 20        teor4:  lda zpEO,x
00391E  1  8D 03 02             sta abst
003921  1  A9 00 48 BD          set_ax  absEOa,0
003925  1  5E 02 28     
003928  1  4D 03 02             eor abst
00392B  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00392F  1  D0 FE 68 49  
003933  1  30 DD 66 02  
003939  1  CA                   dex
00393A  1  10 E0                bpl teor4
00393C  1  A2 03                ldx #3
00393E  1  B5 20        teor5:  lda zpEO,x
003940  1  8D 03 02             sta abst
003943  1  A9 FF 48 BD          set_ax  absEOa,$ff
003947  1  5E 02 28     
00394A  1  4D 03 02             eor abst
00394D  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003951  1  D0 FE 68 49  
003955  1  7D DD 66 02  
00395B  1  CA                   dex
00395C  1  10 02                bpl teor6
00395E  1               
00395E  1  A2 03                ldx #3      ;zp,x
003960  1               teor6:
003960  1  A9 00 48 BD          set_ax  absEOa,0
003964  1  5E 02 28     
003967  1  55 20                eor zpEO,x
003969  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00396D  1  D0 FE 68 49  
003971  1  30 DD 66 02  
003977  1  CA                   dex
003978  1  10 E6                bpl teor6
00397A  1  A2 03                ldx #3
00397C  1               teor7:
00397C  1  A9 FF 48 BD          set_ax  absEOa,$ff
003980  1  5E 02 28     
003983  1  55 20                eor zpEO,x
003985  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003989  1  D0 FE 68 49  
00398D  1  7D DD 66 02  
003993  1  CA                   dex
003994  1  10 E6                bpl teor7
003996  1               
003996  1  A2 03                ldx #3      ;abs,x
003998  1               teor8:
003998  1  A9 00 48 BD          set_ax  absEOa,0
00399C  1  5E 02 28     
00399F  1  5D 52 02             eor absEO,x
0039A2  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0039A6  1  D0 FE 68 49  
0039AA  1  30 DD 66 02  
0039B0  1  CA                   dex
0039B1  1  10 E5                bpl teor8
0039B3  1  A2 03                ldx #3
0039B5  1               teor9:
0039B5  1  A9 FF 48 BD          set_ax  absEOa,$ff
0039B9  1  5E 02 28     
0039BC  1  5D 52 02             eor absEO,x
0039BF  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0039C3  1  D0 FE 68 49  
0039C7  1  7D DD 66 02  
0039CD  1  CA                   dex
0039CE  1  10 E5                bpl teor9
0039D0  1               
0039D0  1  A0 03                ldy #3      ;abs,y
0039D2  1               teor10:
0039D2  1  A9 00 48 B9          set_ay  absEOa,0
0039D6  1  5E 02 28     
0039D9  1  59 52 02             eor absEO,y
0039DC  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0039E0  1  D0 FE 68 49  
0039E4  1  30 D9 66 02  
0039EA  1  88                   dey
0039EB  1  10 E5                bpl teor10
0039ED  1  A0 03                ldy #3
0039EF  1               teor11:
0039EF  1  A9 FF 48 B9          set_ay  absEOa,$ff
0039F3  1  5E 02 28     
0039F6  1  59 52 02             eor absEO,y
0039F9  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0039FD  1  D0 FE 68 49  
003A01  1  7D D9 66 02  
003A07  1  88                   dey
003A08  1  10 E5                bpl teor11
003A0A  1               
003A0A  1  A2 06                ldx #6      ;(zp,x)
003A0C  1  A0 03                ldy #3
003A0E  1               teor12:
003A0E  1  A9 00 48 B9          set_ay  absEOa,0
003A12  1  5E 02 28     
003A15  1  41 42                eor (indEO,x)
003A17  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003A1B  1  D0 FE 68 49  
003A1F  1  30 D9 66 02  
003A25  1  CA                   dex
003A26  1  CA                   dex
003A27  1  88                   dey
003A28  1  10 E4                bpl teor12
003A2A  1  A2 06                ldx #6
003A2C  1  A0 03                ldy #3
003A2E  1               teor13:
003A2E  1  A9 FF 48 B9          set_ay  absEOa,$ff
003A32  1  5E 02 28     
003A35  1  41 42                eor (indEO,x)
003A37  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003A3B  1  D0 FE 68 49  
003A3F  1  7D D9 66 02  
003A45  1  CA                   dex
003A46  1  CA                   dex
003A47  1  88                   dey
003A48  1  10 E4                bpl teor13
003A4A  1               
003A4A  1  A0 03                ldy #3      ;(zp),y
003A4C  1               teor14:
003A4C  1  A9 00 48 B9          set_ay  absEOa,0
003A50  1  5E 02 28     
003A53  1  51 42                eor (indEO),y
003A55  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003A59  1  D0 FE 68 49  
003A5D  1  30 D9 66 02  
003A63  1  88                   dey
003A64  1  10 E6                bpl teor14
003A66  1  A0 03                ldy #3
003A68  1               teor15:
003A68  1  A9 FF 48 B9          set_ay  absEOa,$ff
003A6C  1  5E 02 28     
003A6F  1  51 42                eor (indEO),y
003A71  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003A75  1  D0 FE 68 49  
003A79  1  7D D9 66 02  
003A7F  1  88                   dey
003A80  1  10 E6                bpl teor15
003A82  1  AD 00 02 C9          next_test
003A86  1  27 D0 FE A9  
003A8A  1  28 8D 00 02  
003ACB  1               
003ACB  1               ; OR
003ACB  1  A2 03                ldx #3          ;immediate - self modifying code
003ACD  1  B5 18        tora:   lda zpOR,x
003ACF  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
003AD2  1  A9 00 48 BD          set_ax  absORa,0
003AD6  1  56 02 28     
003AD9  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003ADC  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003AE0  1  D0 FE 68 49  
003AE4  1  30 DD 66 02  
003AEA  1  CA                   dex
003AEB  1  10 E0                bpl tora
003AED  1  A2 03                ldx #3
003AEF  1  B5 18        tora1:  lda zpOR,x
003AF1  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
003AF4  1  A9 FF 48 BD          set_ax  absORa,$ff
003AF8  1  56 02 28     
003AFB  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003AFE  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003B02  1  D0 FE 68 49  
003B06  1  7D DD 66 02  
003B0C  1  CA                   dex
003B0D  1  10 E0                bpl tora1
003B0F  1               
003B0F  1  A2 03                ldx #3      ;zp
003B11  1  B5 18        tora2:  lda zpOR,x
003B13  1  85 0C                sta zpt
003B15  1  A9 00 48 BD          set_ax  absORa,0
003B19  1  56 02 28     
003B1C  1  05 0C                ora zpt
003B1E  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003B22  1  D0 FE 68 49  
003B26  1  30 DD 66 02  
003B2C  1  CA                   dex
003B2D  1  10 E2                bpl tora2
003B2F  1  A2 03                ldx #3
003B31  1  B5 18        tora3:  lda zpOR,x
003B33  1  85 0C                sta zpt
003B35  1  A9 FF 48 BD          set_ax  absORa,$ff
003B39  1  56 02 28     
003B3C  1  05 0C                ora zpt
003B3E  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003B42  1  D0 FE 68 49  
003B46  1  7D DD 66 02  
003B4C  1  CA                   dex
003B4D  1  10 E2                bpl tora3
003B4F  1               
003B4F  1  A2 03                ldx #3      ;abs
003B51  1  B5 18        tora4:  lda zpOR,x
003B53  1  8D 03 02             sta abst
003B56  1  A9 00 48 BD          set_ax  absORa,0
003B5A  1  56 02 28     
003B5D  1  0D 03 02             ora abst
003B60  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003B64  1  D0 FE 68 49  
003B68  1  30 DD 66 02  
003B6E  1  CA                   dex
003B6F  1  10 E0                bpl tora4
003B71  1  A2 03                ldx #3
003B73  1  B5 18        tora5:  lda zpOR,x
003B75  1  8D 03 02             sta abst
003B78  1  A9 FF 48 BD          set_ax  absORa,$ff
003B7C  1  56 02 28     
003B7F  1  0D 03 02             ora abst
003B82  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003B86  1  D0 FE 68 49  
003B8A  1  7D DD 66 02  
003B90  1  CA                   dex
003B91  1  10 02                bpl tora6
003B93  1               
003B93  1  A2 03                ldx #3      ;zp,x
003B95  1               tora6:
003B95  1  A9 00 48 BD          set_ax  absORa,0
003B99  1  56 02 28     
003B9C  1  15 18                ora zpOR,x
003B9E  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003BA2  1  D0 FE 68 49  
003BA6  1  30 DD 66 02  
003BAC  1  CA                   dex
003BAD  1  10 E6                bpl tora6
003BAF  1  A2 03                ldx #3
003BB1  1               tora7:
003BB1  1  A9 FF 48 BD          set_ax  absORa,$ff
003BB5  1  56 02 28     
003BB8  1  15 18                ora zpOR,x
003BBA  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003BBE  1  D0 FE 68 49  
003BC2  1  7D DD 66 02  
003BC8  1  CA                   dex
003BC9  1  10 E6                bpl tora7
003BCB  1               
003BCB  1  A2 03                ldx #3      ;abs,x
003BCD  1               tora8:
003BCD  1  A9 00 48 BD          set_ax  absORa,0
003BD1  1  56 02 28     
003BD4  1  1D 4A 02             ora absOR,x
003BD7  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003BDB  1  D0 FE 68 49  
003BDF  1  30 DD 66 02  
003BE5  1  CA                   dex
003BE6  1  10 E5                bpl tora8
003BE8  1  A2 03                ldx #3
003BEA  1               tora9:
003BEA  1  A9 FF 48 BD          set_ax  absORa,$ff
003BEE  1  56 02 28     
003BF1  1  1D 4A 02             ora absOR,x
003BF4  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003BF8  1  D0 FE 68 49  
003BFC  1  7D DD 66 02  
003C02  1  CA                   dex
003C03  1  10 E5                bpl tora9
003C05  1               
003C05  1  A0 03                ldy #3      ;abs,y
003C07  1               tora10:
003C07  1  A9 00 48 B9          set_ay  absORa,0
003C0B  1  56 02 28     
003C0E  1  19 4A 02             ora absOR,y
003C11  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003C15  1  D0 FE 68 49  
003C19  1  30 D9 66 02  
003C1F  1  88                   dey
003C20  1  10 E5                bpl tora10
003C22  1  A0 03                ldy #3
003C24  1               tora11:
003C24  1  A9 FF 48 B9          set_ay  absORa,$ff
003C28  1  56 02 28     
003C2B  1  19 4A 02             ora absOR,y
003C2E  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003C32  1  D0 FE 68 49  
003C36  1  7D D9 66 02  
003C3C  1  88                   dey
003C3D  1  10 E5                bpl tora11
003C3F  1               
003C3F  1  A2 06                ldx #6      ;(zp,x)
003C41  1  A0 03                ldy #3
003C43  1               tora12:
003C43  1  A9 00 48 B9          set_ay  absORa,0
003C47  1  56 02 28     
003C4A  1  01 4A                ora (indOR,x)
003C4C  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003C50  1  D0 FE 68 49  
003C54  1  30 D9 66 02  
003C5A  1  CA                   dex
003C5B  1  CA                   dex
003C5C  1  88                   dey
003C5D  1  10 E4                bpl tora12
003C5F  1  A2 06                ldx #6
003C61  1  A0 03                ldy #3
003C63  1               tora13:
003C63  1  A9 FF 48 B9          set_ay  absORa,$ff
003C67  1  56 02 28     
003C6A  1  01 4A                ora (indOR,x)
003C6C  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003C70  1  D0 FE 68 49  
003C74  1  7D D9 66 02  
003C7A  1  CA                   dex
003C7B  1  CA                   dex
003C7C  1  88                   dey
003C7D  1  10 E4                bpl tora13
003C7F  1               
003C7F  1  A0 03                ldy #3      ;(zp),y
003C81  1               tora14:
003C81  1  A9 00 48 B9          set_ay  absORa,0
003C85  1  56 02 28     
003C88  1  11 4A                ora (indOR),y
003C8A  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003C8E  1  D0 FE 68 49  
003C92  1  30 D9 66 02  
003C98  1  88                   dey
003C99  1  10 E6                bpl tora14
003C9B  1  A0 03                ldy #3
003C9D  1               tora15:
003C9D  1  A9 FF 48 B9          set_ay  absORa,$ff
003CA1  1  56 02 28     
003CA4  1  11 4A                ora (indOR),y
003CA6  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003CAA  1  D0 FE 68 49  
003CAE  1  7D D9 66 02  
003CB4  1  88                   dey
003CB5  1  10 E6                bpl tora15
003CB7  1                   .if I_flag = 3
003CB7  1  58                   cli
003CB8  1                   .endif
003CB8  1  AD 00 02 C9          next_test
003CBC  1  28 D0 FE A9  
003CC0  1  29 8D 00 02  
003D01  1               
003D01  1               ; full binary add/subtract test
003D01  1               ; iterates through all combinations of operands and carry input
003D01  1               ; uses increments/decrements to predict result & result flags
003D01  1  D8                   cld
003D02  1  A2 0E                ldx #ad2        ;for indexed test
003D04  1  A0 FF                ldy #$ff        ;max range
003D06  1  A9 00                lda #0          ;start with adding zeroes & no carry
003D08  1  85 0C                sta adfc        ;carry in - for diag
003D0A  1  85 0D                sta ad1         ;operand 1 - accumulator
003D0C  1  85 0E                sta ad2         ;operand 2 - memory or immediate
003D0E  1  8D 03 02             sta ada2        ;non zp
003D11  1  85 0F                sta adrl        ;expected result bits 0-7
003D13  1  85 10                sta adrh        ;expected result bit 8 (carry out)
003D15  1  A9 FF                lda #$ff        ;complemented operand 2 for subtract
003D17  1  85 12                sta sb2
003D19  1  8D 04 02             sta sba2        ;non zp
003D1C  1  A9 02                lda #2          ;expected Z-flag
003D1E  1  85 11                sta adrf
003D20  1  18           tadd:   clc             ;test with carry clear
003D21  1  20 A9 3D             jsr chkadd
003D24  1  E6 0C                inc adfc        ;now with carry
003D26  1  E6 0F                inc adrl        ;result +1
003D28  1  08                   php             ;save N & Z from low result
003D29  1  08                   php
003D2A  1  68                   pla             ;accu holds expected flags
003D2B  1  29 82                and #$82        ;mask N & Z
003D2D  1  28                   plp
003D2E  1  D0 02                bne tadd1
003D30  1  E6 10                inc adrh        ;result bit 8 - carry
003D32  1  05 10        tadd1:  ora adrh        ;merge C to expected flags
003D34  1  85 11                sta adrf        ;save expected flags except overflow
003D36  1  38                   sec             ;test with carry set
003D37  1  20 A9 3D             jsr chkadd
003D3A  1  C6 0C                dec adfc        ;same for operand +1 but no carry
003D3C  1  E6 0D                inc ad1
003D3E  1  D0 E0                bne tadd        ;iterate op1
003D40  1  A9 00                lda #0          ;preset result to op2 when op1 = 0
003D42  1  85 10                sta adrh
003D44  1  EE 03 02             inc ada2
003D47  1  E6 0E                inc ad2
003D49  1  08                   php             ;save NZ as operand 2 becomes the new result
003D4A  1  68                   pla
003D4B  1  29 82                and #$82        ;mask N00000Z0
003D4D  1  85 11                sta adrf        ;no need to check carry as we are adding to 0
003D4F  1  C6 12                dec sb2         ;complement subtract operand 2
003D51  1  CE 04 02             dec sba2
003D54  1  A5 0E                lda ad2
003D56  1  85 0F                sta adrl
003D58  1  D0 C6                bne tadd        ;iterate op2
003D5A  1                   .if disable_decimal < 1
003D5A  1                       next_test
003D5A  1               
003D5A  1               ; decimal add/subtract test
003D5A  1               ; *** WARNING - tests documented behavior only! ***
003D5A  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003D5A  1               ; iterates through all valid combinations of operands and carry input
003D5A  1               ; uses increments/decrements to predict result & carry flag
003D5A  1                       sed
003D5A  1                       ldx #ad2        ;for indexed test
003D5A  1                       ldy #$ff        ;max range
003D5A  1                       lda #$99        ;start with adding 99 to 99 with carry
003D5A  1                       sta ad1         ;operand 1 - accumulator
003D5A  1                       sta ad2         ;operand 2 - memory or immediate
003D5A  1                       sta ada2        ;non zp
003D5A  1                       sta adrl        ;expected result bits 0-7
003D5A  1                       lda #1          ;set carry in & out
003D5A  1                       sta adfc        ;carry in - for diag
003D5A  1                       sta adrh        ;expected result bit 8 (carry out)
003D5A  1                       lda #0          ;complemented operand 2 for subtract
003D5A  1                       sta sb2
003D5A  1                       sta sba2        ;non zp
003D5A  1               tdad:   sec             ;test with carry set
003D5A  1                       jsr chkdad
003D5A  1                       dec adfc        ;now with carry clear
003D5A  1                       lda adrl        ;decimal adjust result
003D5A  1                       bne tdad1       ;skip clear carry & preset result 99 (9A-1)
003D5A  1                       dec adrh
003D5A  1                       lda #$99
003D5A  1                       sta adrl
003D5A  1                       bne tdad3
003D5A  1               tdad1:  and #$f         ;lower nibble mask
003D5A  1                       bne tdad2       ;no decimal adjust needed
003D5A  1                       dec adrl        ;decimal adjust (?0-6)
003D5A  1                       dec adrl
003D5A  1                       dec adrl
003D5A  1                       dec adrl
003D5A  1                       dec adrl
003D5A  1                       dec adrl
003D5A  1               tdad2:  dec adrl        ;result -1
003D5A  1               tdad3:  clc             ;test with carry clear
003D5A  1                       jsr chkdad
003D5A  1                       inc adfc        ;same for operand -1 but with carry
003D5A  1                       lda ad1         ;decimal adjust operand 1
003D5A  1                       beq tdad5       ;iterate operand 2
003D5A  1                       and #$f         ;lower nibble mask
003D5A  1                       bne tdad4       ;skip decimal adjust
003D5A  1                       dec ad1         ;decimal adjust (?0-6)
003D5A  1                       dec ad1
003D5A  1                       dec ad1
003D5A  1                       dec ad1
003D5A  1                       dec ad1
003D5A  1                       dec ad1
003D5A  1               tdad4:  dec ad1         ;operand 1 -1
003D5A  1                       jmp tdad        ;iterate op1
003D5A  1               
003D5A  1               tdad5:  lda #$99        ;precharge op1 max
003D5A  1                       sta ad1
003D5A  1                       lda ad2         ;decimal adjust operand 2
003D5A  1                       beq tdad7       ;end of iteration
003D5A  1                       and #$f         ;lower nibble mask
003D5A  1                       bne tdad6       ;skip decimal adjust
003D5A  1                       dec ad2         ;decimal adjust (?0-6)
003D5A  1                       dec ad2
003D5A  1                       dec ad2
003D5A  1                       dec ad2
003D5A  1                       dec ad2
003D5A  1                       dec ad2
003D5A  1                       inc sb2         ;complemented decimal adjust for subtract (?9+6)
003D5A  1                       inc sb2
003D5A  1                       inc sb2
003D5A  1                       inc sb2
003D5A  1                       inc sb2
003D5A  1                       inc sb2
003D5A  1               tdad6:  dec ad2         ;operand 2 -1
003D5A  1                       inc sb2         ;complemented operand for subtract
003D5A  1                       lda sb2
003D5A  1                       sta sba2        ;copy as non zp operand
003D5A  1                       lda ad2
003D5A  1                       sta ada2        ;copy as non zp operand
003D5A  1                       sta adrl        ;new result since op1+carry=00+carry +op2=op2
003D5A  1                       inc adrh        ;result carry
003D5A  1                       bne tdad        ;iterate op2
003D5A  1               tdad7:
003D5A  1                       next_test
003D5A  1               
003D5A  1               ; decimal/binary switch test
003D5A  1               ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
003D5A  1               ;   tables
003D5A  1                       clc
003D5A  1                       cld
003D5A  1                       php
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$aa
003D5A  1                       trap_ne         ;expected binary result after cld
003D5A  1                       clc
003D5A  1                       sed
003D5A  1                       php
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$10
003D5A  1                       trap_ne         ;expected decimal result after sed
003D5A  1                       cld
003D5A  1                       plp
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$10
003D5A  1                       trap_ne         ;expected decimal result after plp D=1
003D5A  1                       plp
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$aa
003D5A  1                       trap_ne         ;expected binary result after plp D=0
003D5A  1                       clc
003D5A  1                       lda #>bin_rti_ret ;emulated interrupt for rti
003D5A  1                       pha
003D5A  1                       lda #<bin_rti_ret
003D5A  1                       pha
003D5A  1                       php
003D5A  1                       sed
003D5A  1                       lda #>dec_rti_ret ;emulated interrupt for rti
003D5A  1                       pha
003D5A  1                       lda #<dec_rti_ret
003D5A  1                       pha
003D5A  1                       php
003D5A  1                       cld
003D5A  1                       rti
003D5A  1               dec_rti_ret:
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$10
003D5A  1                       trap_ne         ;expected decimal result after rti D=1
003D5A  1                       rti
003D5A  1               bin_rti_ret:
003D5A  1                       lda #$55
003D5A  1                       adc #$55
003D5A  1                       cmp #$aa
003D5A  1                       trap_ne         ;expected binary result after rti D=0
003D5A  1                   .endif
003D5A  1               
003D5A  1  AD 00 02             lda test_case
003D5D  1  C9 29                cmp #test_num
003D5F  1  D0 FE                trap_ne         ;previous test is out of sequence
003D61  1  A9 F0                lda #$f0        ;mark opcode testing complete
003D63  1  8D 00 02             sta test_case
003D66  1               
003D66  1               ; final RAM integrity test
003D66  1               ;   verifies that none of the previous tests has altered RAM outside of the
003D66  1               ;   designated write areas.
003D66  1  1A D8 A9 00          check_ram
003D6A  1  85 0C 85 0F  
003D6E  1  8D 57 05 18  
003DA3  1               ; *** DEBUG INFO ***
003DA3  1               ; to debug checksum errors uncomment check_ram in the next_test macro to
003DA3  1               ; narrow down the responsible opcode.
003DA3  1               ; may give false errors when monitor, OS or other background activity is
003DA3  1               ; allowed during previous tests.
003DA3  1               
003DA3  1               
003DA3  1               ; S U C C E S S ************************************************
003DA3  1               ; -------------
003DA3  1  4C A3 3D             success         ;if you get here everything went well
003DA6  1               ; -------------
003DA6  1               ; S U C C E S S ************************************************
003DA6  1  4C 00 04             jmp start       ;run again
003DA9  1               
003DA9  1                   .if disable_decimal < 1
003DA9  1               ; core subroutine of the decimal add/subtract test
003DA9  1               ; *** WARNING - tests documented behavior only! ***
003DA9  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003DA9  1               ; iterates through all valid combinations of operands and carry input
003DA9  1               ; uses increments/decrements to predict result & carry flag
003DA9  1               chkdad:
003DA9  1               ; decimal ADC / SBC zp
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc ad2         ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc sb2         ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad flags
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC abs
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc ada2        ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc sba2        ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC #
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad2
003DA9  1                       sta ex_adci+1   ;set ADC # operand
003DA9  1                       lda ad1
003DA9  1                       jsr ex_adci     ;execute ADC # in RAM
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda sb2
003DA9  1                       sta ex_sbci+1   ;set SBC # operand
003DA9  1                       lda ad1
003DA9  1                       jsr ex_sbci     ;execute SBC # in RAM
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC zp,x
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc 0,x         ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc sb2-ad2,x   ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC abs,x
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc ada2-ad2,x  ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc sba2-ad2,x  ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC abs,y
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc ada2-$ff,y  ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc sba2-$ff,y  ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC (zp,x)
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc (<adi2-ad2,x) ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc (<sbi2-ad2,x) ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1               ; decimal ADC / SBC (abs),y
003DA9  1                       php             ;save carry for subtract
003DA9  1                       lda ad1
003DA9  1                       adc (adiy2),y   ;perform add
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       php             ;save carry for next add
003DA9  1                       lda ad1
003DA9  1                       sbc (sbiy2),y   ;perform subtract
003DA9  1                       php
003DA9  1                       cmp adrl        ;check result
003DA9  1                       trap_ne         ;bad result
003DA9  1                       pla             ;check flags
003DA9  1                       and #1          ;mask carry
003DA9  1                       cmp adrh
003DA9  1                       trap_ne         ;bad carry
003DA9  1                       plp
003DA9  1                       rts
003DA9  1                   .endif
003DA9  1               
003DA9  1               ; core subroutine of the full binary add/subtract test
003DA9  1               ; iterates through all combinations of operands and carry input
003DA9  1               ; uses increments/decrements to predict result & result flags
003DA9  1  A5 11        chkadd: lda adrf        ;add V-flag if overflow
003DAB  1  29 83                and #$83        ;keep N-----ZC / clear V
003DAD  1  48                   pha
003DAE  1  A5 0D                lda ad1         ;test sign unequal between operands
003DB0  1  45 0E                eor ad2
003DB2  1  30 0A                bmi ckad1       ;no overflow possible - operands have different sign
003DB4  1  A5 0D                lda ad1         ;test sign equal between operands and result
003DB6  1  45 0F                eor adrl
003DB8  1  10 04                bpl ckad1       ;no overflow occured - operand and result have same sign
003DBA  1  68                   pla
003DBB  1  09 40                ora #$40        ;set V
003DBD  1  48                   pha
003DBE  1  68           ckad1:  pla
003DBF  1  85 11                sta adrf        ;save expected flags
003DC1  1               ; binary ADC / SBC zp
003DC1  1  08                   php             ;save carry for subtract
003DC2  1  A5 0D                lda ad1
003DC4  1  65 0E                adc ad2         ;perform add
003DC6  1  08                   php
003DC7  1  C5 0F                cmp adrl        ;check result
003DC9  1  D0 FE                trap_ne         ;bad result
003DCB  1  68                   pla             ;check flags
003DCC  1  29 C3                and #$c3        ;mask NV----ZC
003DCE  1  C5 11                cmp adrf
003DD0  1  D0 FE                trap_ne         ;bad flags
003DD2  1  28                   plp
003DD3  1  08                   php             ;save carry for next add
003DD4  1  A5 0D                lda ad1
003DD6  1  E5 12                sbc sb2         ;perform subtract
003DD8  1  08                   php
003DD9  1  C5 0F                cmp adrl        ;check result
003DDB  1  D0 FE                trap_ne         ;bad result
003DDD  1  68                   pla             ;check flags
003DDE  1  29 C3                and #$c3        ;mask NV----ZC
003DE0  1  C5 11                cmp adrf
003DE2  1  D0 FE                trap_ne         ;bad flags
003DE4  1  28                   plp
003DE5  1               ; binary ADC / SBC abs
003DE5  1  08                   php             ;save carry for subtract
003DE6  1  A5 0D                lda ad1
003DE8  1  6D 03 02             adc ada2        ;perform add
003DEB  1  08                   php
003DEC  1  C5 0F                cmp adrl        ;check result
003DEE  1  D0 FE                trap_ne         ;bad result
003DF0  1  68                   pla             ;check flags
003DF1  1  29 C3                and #$c3        ;mask NV----ZC
003DF3  1  C5 11                cmp adrf
003DF5  1  D0 FE                trap_ne         ;bad flags
003DF7  1  28                   plp
003DF8  1  08                   php             ;save carry for next add
003DF9  1  A5 0D                lda ad1
003DFB  1  ED 04 02             sbc sba2        ;perform subtract
003DFE  1  08                   php
003DFF  1  C5 0F                cmp adrl        ;check result
003E01  1  D0 FE                trap_ne         ;bad result
003E03  1  68                   pla             ;check flags
003E04  1  29 C3                and #$c3        ;mask NV----ZC
003E06  1  C5 11                cmp adrf
003E08  1  D0 FE                trap_ne         ;bad flags
003E0A  1  28                   plp
003E0B  1               ; binary ADC / SBC #
003E0B  1  08                   php             ;save carry for subtract
003E0C  1  A5 0E                lda ad2
003E0E  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
003E11  1  A5 0D                lda ad1
003E13  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
003E16  1  08                   php
003E17  1  C5 0F                cmp adrl        ;check result
003E19  1  D0 FE                trap_ne         ;bad result
003E1B  1  68                   pla             ;check flags
003E1C  1  29 C3                and #$c3        ;mask NV----ZC
003E1E  1  C5 11                cmp adrf
003E20  1  D0 FE                trap_ne         ;bad flags
003E22  1  28                   plp
003E23  1  08                   php             ;save carry for next add
003E24  1  A5 12                lda sb2
003E26  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
003E29  1  A5 0D                lda ad1
003E2B  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
003E2E  1  08                   php
003E2F  1  C5 0F                cmp adrl        ;check result
003E31  1  D0 FE                trap_ne         ;bad result
003E33  1  68                   pla             ;check flags
003E34  1  29 C3                and #$c3        ;mask NV----ZC
003E36  1  C5 11                cmp adrf
003E38  1  D0 FE                trap_ne         ;bad flags
003E3A  1  28                   plp
003E3B  1               ; binary ADC / SBC zp,x
003E3B  1  08                   php             ;save carry for subtract
003E3C  1  A5 0D                lda ad1
003E3E  1  75 00                adc 0,x         ;perform add
003E40  1  08                   php
003E41  1  C5 0F                cmp adrl        ;check result
003E43  1  D0 FE                trap_ne         ;bad result
003E45  1  68                   pla             ;check flags
003E46  1  29 C3                and #$c3        ;mask NV----ZC
003E48  1  C5 11                cmp adrf
003E4A  1  D0 FE                trap_ne         ;bad flags
003E4C  1  28                   plp
003E4D  1  08                   php             ;save carry for next add
003E4E  1  A5 0D                lda ad1
003E50  1  F5 04                sbc sb2-ad2,x   ;perform subtract
003E52  1  08                   php
003E53  1  C5 0F                cmp adrl        ;check result
003E55  1  D0 FE                trap_ne         ;bad result
003E57  1  68                   pla             ;check flags
003E58  1  29 C3                and #$c3        ;mask NV----ZC
003E5A  1  C5 11                cmp adrf
003E5C  1  D0 FE                trap_ne         ;bad flags
003E5E  1  28                   plp
003E5F  1               ; binary ADC / SBC abs,x
003E5F  1  08                   php             ;save carry for subtract
003E60  1  A5 0D                lda ad1
003E62  1  7D F5 01             adc ada2-ad2,x  ;perform add
003E65  1  08                   php
003E66  1  C5 0F                cmp adrl        ;check result
003E68  1  D0 FE                trap_ne         ;bad result
003E6A  1  68                   pla             ;check flags
003E6B  1  29 C3                and #$c3        ;mask NV----ZC
003E6D  1  C5 11                cmp adrf
003E6F  1  D0 FE                trap_ne         ;bad flags
003E71  1  28                   plp
003E72  1  08                   php             ;save carry for next add
003E73  1  A5 0D                lda ad1
003E75  1  FD F6 01             sbc sba2-ad2,x  ;perform subtract
003E78  1  08                   php
003E79  1  C5 0F                cmp adrl        ;check result
003E7B  1  D0 FE                trap_ne         ;bad result
003E7D  1  68                   pla             ;check flags
003E7E  1  29 C3                and #$c3        ;mask NV----ZC
003E80  1  C5 11                cmp adrf
003E82  1  D0 FE                trap_ne         ;bad flags
003E84  1  28                   plp
003E85  1               ; binary ADC / SBC abs,y
003E85  1  08                   php             ;save carry for subtract
003E86  1  A5 0D                lda ad1
003E88  1  79 04 01             adc ada2-$ff,y  ;perform add
003E8B  1  08                   php
003E8C  1  C5 0F                cmp adrl        ;check result
003E8E  1  D0 FE                trap_ne         ;bad result
003E90  1  68                   pla             ;check flags
003E91  1  29 C3                and #$c3        ;mask NV----ZC
003E93  1  C5 11                cmp adrf
003E95  1  D0 FE                trap_ne         ;bad flags
003E97  1  28                   plp
003E98  1  08                   php             ;save carry for next add
003E99  1  A5 0D                lda ad1
003E9B  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
003E9E  1  08                   php
003E9F  1  C5 0F                cmp adrl        ;check result
003EA1  1  D0 FE                trap_ne         ;bad result
003EA3  1  68                   pla             ;check flags
003EA4  1  29 C3                and #$c3        ;mask NV----ZC
003EA6  1  C5 11                cmp adrf
003EA8  1  D0 FE                trap_ne         ;bad flags
003EAA  1  28                   plp
003EAB  1               ; binary ADC / SBC (zp,x)
003EAB  1  08                   php             ;save carry for subtract
003EAC  1  A5 0D                lda ad1
003EAE  1  61 44                adc (<adi2-ad2,x) ;perform add
003EB0  1  08                   php
003EB1  1  C5 0F                cmp adrl        ;check result
003EB3  1  D0 FE                trap_ne         ;bad result
003EB5  1  68                   pla             ;check flags
003EB6  1  29 C3                and #$c3        ;mask NV----ZC
003EB8  1  C5 11                cmp adrf
003EBA  1  D0 FE                trap_ne         ;bad flags
003EBC  1  28                   plp
003EBD  1  08                   php             ;save carry for next add
003EBE  1  A5 0D                lda ad1
003EC0  1  E1 46                sbc (<sbi2-ad2,x) ;perform subtract
003EC2  1  08                   php
003EC3  1  C5 0F                cmp adrl        ;check result
003EC5  1  D0 FE                trap_ne         ;bad result
003EC7  1  68                   pla             ;check flags
003EC8  1  29 C3                and #$c3        ;mask NV----ZC
003ECA  1  C5 11                cmp adrf
003ECC  1  D0 FE                trap_ne         ;bad flags
003ECE  1  28                   plp
003ECF  1               ; binary ADC / SBC (abs),y
003ECF  1  08                   php             ;save carry for subtract
003ED0  1  A5 0D                lda ad1
003ED2  1  71 56                adc (adiy2),y   ;perform add
003ED4  1  08                   php
003ED5  1  C5 0F                cmp adrl        ;check result
003ED7  1  D0 FE                trap_ne         ;bad result
003ED9  1  68                   pla             ;check flags
003EDA  1  29 C3                and #$c3        ;mask NV----ZC
003EDC  1  C5 11                cmp adrf
003EDE  1  D0 FE                trap_ne         ;bad flags
003EE0  1  28                   plp
003EE1  1  08                   php             ;save carry for next add
003EE2  1  A5 0D                lda ad1
003EE4  1  F1 58                sbc (sbiy2),y   ;perform subtract
003EE6  1  08                   php
003EE7  1  C5 0F                cmp adrl        ;check result
003EE9  1  D0 FE                trap_ne         ;bad result
003EEB  1  68                   pla             ;check flags
003EEC  1  29 C3                and #$c3        ;mask NV----ZC
003EEE  1  C5 11                cmp adrf
003EF0  1  D0 FE                trap_ne         ;bad flags
003EF2  1  28                   plp
003EF3  1  60                   rts
003EF4  1               
003EF4  1               ; target for the jump absolute test
003EF4  1  88                   dey
003EF5  1  88                   dey
003EF6  1               test_far:
003EF6  1  08                   php             ;either SP or Y count will fail, if we do not hit
003EF7  1  88                   dey
003EF8  1  88                   dey
003EF9  1  88                   dey
003EFA  1  28                   plp
003EFB  1  B0 FE                trap_cs         ;flags loaded?
003EFD  1  70 FE                trap_vs
003EFF  1  30 FE                trap_mi
003F01  1  F0 FE                trap_eq
003F03  1  C9 46                cmp #'F'        ;registers loaded?
003F05  1  D0 FE                trap_ne
003F07  1  E0 41                cpx #'A'
003F09  1  D0 FE                trap_ne
003F0B  1  C0 4F                cpy #('R'-3)
003F0D  1  D0 FE                trap_ne
003F0F  1  48                   pha             ;save a,x
003F10  1  8A                   txa
003F11  1  48                   pha
003F12  1  BA                   tsx
003F13  1  E0 FD                cpx #$fd        ;check SP
003F15  1  D0 FE                trap_ne
003F17  1  68                   pla             ;restore x
003F18  1  AA                   tax
003F19  1  A9 FF 48 28          set_stat $ff
003F1D  1  68                   pla             ;restore a
003F1E  1  E8                   inx             ;return registers with modifications
003F1F  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003F21  1  4C 2B 0B             jmp far_ret
003F24  1               
003F24  1               ; target for the jump indirect test
003F24  1               ;       .align 2
003F24  1                       .if * & 1       ; workaround for problems with .align 2
003F24  1                           .byte 0     ;
003F24  1                       .endif          ;
003F24  1               ptr_tst_ind:
003F24  1  2D 3F                .word   test_ind
003F26  1               ptr_ind_ret:
003F26  1  BD 0B                .word   ind_ret
003F28  1  4C 28 3F             trap            ;runover protection
003F2B  1  88                   dey
003F2C  1  88                   dey
003F2D  1               test_ind:
003F2D  1  08                   php             ;either SP or Y count will fail, if we do not hit
003F2E  1  88                   dey
003F2F  1  88                   dey
003F30  1  88                   dey
003F31  1  28                   plp
003F32  1  B0 FE                trap_cs         ;flags loaded?
003F34  1  70 FE                trap_vs
003F36  1  30 FE                trap_mi
003F38  1  F0 FE                trap_eq
003F3A  1  C9 49                cmp #'I'        ;registers loaded?
003F3C  1  D0 FE                trap_ne
003F3E  1  E0 4E                cpx #'N'
003F40  1  D0 FE                trap_ne
003F42  1  C0 41                cpy #('D'-3)
003F44  1  D0 FE                trap_ne
003F46  1  48                   pha             ;save a,x
003F47  1  8A                   txa
003F48  1  48                   pha
003F49  1  BA                   tsx
003F4A  1  E0 FD                cpx #$fd        ;check SP
003F4C  1  D0 FE                trap_ne
003F4E  1  68                   pla             ;restore x
003F4F  1  AA                   tax
003F50  1  A9 FF 48 28          set_stat $ff
003F54  1  68                   pla             ;restore a
003F55  1  E8                   inx             ;return registers with modifications
003F56  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003F58  1  6C 26 3F             jmp (ptr_ind_ret)
003F5B  1  4C 5B 3F             trap            ;runover protection
003F5E  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003F61  1               
003F61  1               ; target for the jump subroutine test
003F61  1  88                   dey
003F62  1  88                   dey
003F63  1               test_jsr:
003F63  1  08                   php             ;either SP or Y count will fail, if we do not hit
003F64  1  88                   dey
003F65  1  88                   dey
003F66  1  88                   dey
003F67  1  28                   plp
003F68  1  B0 FE                trap_cs         ;flags loaded?
003F6A  1  70 FE                trap_vs
003F6C  1  30 FE                trap_mi
003F6E  1  F0 FE                trap_eq
003F70  1  C9 4A                cmp #'J'        ;registers loaded?
003F72  1  D0 FE                trap_ne
003F74  1  E0 53                cpx #'S'
003F76  1  D0 FE                trap_ne
003F78  1  C0 4F                cpy #('R'-3)
003F7A  1  D0 FE                trap_ne
003F7C  1  48                   pha             ;save a,x
003F7D  1  8A                   txa
003F7E  1  48                   pha
003F7F  1  BA                   tsx             ;sp -4? (return addr,a,x)
003F80  1  E0 FB                cpx #$fb
003F82  1  D0 FE                trap_ne
003F84  1  AD FF 01             lda $1ff        ;propper return on stack
003F87  1  C9 0C                cmp #>jsr_ret
003F89  1  D0 FE                trap_ne
003F8B  1  AD FE 01             lda $1fe
003F8E  1  C9 30                cmp #<jsr_ret
003F90  1  D0 FE                trap_ne
003F92  1  A9 FF 48 28          set_stat $ff
003F96  1  68                   pla             ;pull x,a
003F97  1  AA                   tax
003F98  1  68                   pla
003F99  1  E8                   inx             ;return registers with modifications
003F9A  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003F9C  1  60                   rts
003F9D  1  4C 9D 3F             trap            ;runover protection
003FA0  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003FA3  1               
003FA3  1               ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
003FA3  1               nmi_trap:
003FA3  1  4C A3 3F             trap            ;check stack for conditions at NMI
003FA6  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003FA9  1               res_trap:
003FA9  1  4C A9 3F             trap            ;unexpected RESET
003FAC  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003FAF  1               
003FAF  1  88                   dey
003FB0  1  88                   dey
003FB1  1               irq_trap:               ;BRK test or unextpected BRK or IRQ
003FB1  1  08                   php             ;either SP or Y count will fail, if we do not hit
003FB2  1  88                   dey
003FB3  1  88                   dey
003FB4  1  88                   dey
003FB5  1                       ;next traps could be caused by unexpected BRK or IRQ
003FB5  1                       ;check stack for BREAK and originating location
003FB5  1                       ;possible jump/branch into weeds (uninitialized space)
003FB5  1  C9 BD                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
003FB7  1  F0 42                beq break2
003FB9  1  C9 42                cmp #'B'        ;BRK pass 1 registers loaded?
003FBB  1  D0 FE                trap_ne
003FBD  1  E0 52                cpx #'R'
003FBF  1  D0 FE                trap_ne
003FC1  1  C0 48                cpy #'K'-3
003FC3  1  D0 FE                trap_ne
003FC5  1  85 0A                sta irq_a       ;save registers during break test
003FC7  1  86 0B                stx irq_x
003FC9  1  BA                   tsx             ;test break on stack
003FCA  1  BD 02 01             lda $102,x
003FCD  1  C9 30                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
003FCF  1  D0 FE                trap_ne         ; - no break flag on stack
003FD1  1  68                   pla
003FD2  1  C9 34                cmp_flag intdis ;should have added interrupt disable
003FD4  1  D0 FE                trap_ne
003FD6  1  BA                   tsx
003FD7  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
003FD9  1  D0 FE                trap_ne
003FDB  1  AD FF 01             lda $1ff        ;propper return on stack
003FDE  1  C9 0C                cmp #>brk_ret0
003FE0  1  D0 FE                trap_ne
003FE2  1  AD FE 01             lda $1fe
003FE5  1  C9 A4                cmp #<brk_ret0
003FE7  1  D0 FE                trap_ne
003FE9  1  A9 FF                load_flag $ff
003FEB  1  48                   pha
003FEC  1  A6 0B                ldx irq_x
003FEE  1  E8                   inx             ;return registers with modifications
003FEF  1  A5 0A                lda irq_a
003FF1  1  49 AA                eor #$aa
003FF3  1  28                   plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
003FF4  1  40                   rti
003FF5  1  4C F5 3F             trap            ;runover protection
003FF8  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003FFB  1               
003FFB  1               break2:                 ;BRK pass 2
003FFB  1  E0 AD                cpx #$ff-'R'
003FFD  1  D0 FE                trap_ne
003FFF  1  C0 B1                cpy #$ff-'K'-3
004001  1  D0 FE                trap_ne
004003  1  85 0A                sta irq_a       ;save registers during break test
004005  1  86 0B                stx irq_x
004007  1  BA                   tsx             ;test break on stack
004008  1  BD 02 01             lda $102,x
00400B  1  C9 FF                cmp_flag $ff    ;break test should have B=1
00400D  1  D0 FE                trap_ne         ; - no break flag on stack
00400F  1  68                   pla
004010  1  09 08                ora #decmode    ;ignore decmode cleared if 65c02
004012  1  C9 FF                cmp_flag $ff    ;actual passed flags
004014  1  D0 FE                trap_ne
004016  1  BA                   tsx
004017  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
004019  1  D0 FE                trap_ne
00401B  1  AD FF 01             lda $1ff        ;propper return on stack
00401E  1  C9 0C                cmp #>brk_ret1
004020  1  D0 FE                trap_ne
004022  1  AD FE 01             lda $1fe
004025  1  C9 CA                cmp #<brk_ret1
004027  1  D0 FE                trap_ne
004029  1  A9 04                load_flag intdis
00402B  1  48                   pha
00402C  1  A6 0B                ldx irq_x
00402E  1  E8                   inx             ;return registers with modifications
00402F  1  A5 0A                lda irq_a
004031  1  49 AA                eor #$aa
004033  1  28                   plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
004034  1  40                   rti
004035  1  4C 35 40             trap            ;runover protection
004038  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00403B  1               
00403B  1                   .if report = 1
00403B  1                       include "report.i65"
00403B  1                   .endif
00403B  1               
00403B  1               ;copy of data to initialize BSS segment
00403B  1                   .if load_data_direct <> 1
00403B  1               zp_init:
00403B  1               zp1_:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00403B  1               zp7f_:  .byte   $7f             ;test pattern for compare
00403B  1               ;logical zeropage operands
00403B  1               zpOR_:  .byte   0,$1f,$71,$80   ;test pattern for OR
00403B  1               zpAN_:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
00403B  1               zpEO_:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
00403B  1               ;indirect addressing pointers
00403B  1               ind1_:  .word   abs1            ;indirect pointer to pattern in absolute memory
00403B  1                       .word   abs1+1
00403B  1                       .word   abs1+2
00403B  1                       .word   abs1+3
00403B  1                       .word   abs7f
00403B  1               inw1_:  .word   abs1-$f8        ;indirect pointer for wrap-test pattern
00403B  1               indt_:  .word   abst            ;indirect pointer to store area in absolute memory
00403B  1                       .word   abst+1
00403B  1                       .word   abst+2
00403B  1                       .word   abst+3
00403B  1               inwt_:  .word   abst-$f8        ;indirect pointer for wrap-test store
00403B  1               indAN_: .word   absAN           ;indirect pointer to AND pattern in absolute memory
00403B  1                       .word   absAN+1
00403B  1                       .word   absAN+2
00403B  1                       .word   absAN+3
00403B  1               indEO_: .word   absEO           ;indirect pointer to EOR pattern in absolute memory
00403B  1                       .word   absEO+1
00403B  1                       .word   absEO+2
00403B  1                       .word   absEO+3
00403B  1               indOR_: .word   absOR           ;indirect pointer to OR pattern in absolute memory
00403B  1                       .word   absOR+1
00403B  1                       .word   absOR+2
00403B  1                       .word   absOR+3
00403B  1               ;add/subtract indirect pointers
00403B  1               adi2_:  .word   ada2            ;indirect pointer to operand 2 in absolute memory
00403B  1               sbi2_:  .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
00403B  1               adiy2_: .word   ada2-$ff        ;with offset for indirect indexed
00403B  1               sbiy2_: .word   sba2-$ff
00403B  1               zp_end:
00403B  1                   .if (zp_end - zp_init) <> (zp_bss_end - zp_bss)
00403B  1                       ;force assembler error if size is different
00403B  1                       .error "mismatch between bss and zeropage data"
00403B  1                   .endif
00403B  1               data_init:
00403B  1               ex_and_:and #0              ;execute immediate opcodes
00403B  1                       rts
00403B  1               ex_eor_:eor #0              ;execute immediate opcodes
00403B  1                       rts
00403B  1               ex_ora_:ora #0              ;execute immediate opcodes
00403B  1                       rts
00403B  1               ex_adc_:adc #0              ;execute immediate opcodes
00403B  1                       rts
00403B  1               ex_sbc_:sbc #0              ;execute immediate opcodes
00403B  1                       rts
00403B  1               abs1_:  .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00403B  1               abs7f_: .byte   $7f             ;test pattern for compare
00403B  1               ;loads
00403B  1               fLDx_:  .byte   fn,fn,0,fz      ;expected flags for load
00403B  1               ;shifts
00403B  1               rASL_:                      ;expected result ASL & ROL -carry
00403B  1               rROL_:  .byte   $86,$04,$82,0   ; "
00403B  1               rROLc_: .byte   $87,$05,$83,1   ;expected result ROL +carry
00403B  1               rLSR_:                      ;expected result LSR & ROR -carry
00403B  1               rROR_:  .byte   $61,$41,$20,0   ; "
00403B  1               rRORc_: .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
00403B  1               fASL_:                      ;expected flags for shifts
00403B  1               fROL_:  .byte   fnc,fc,fn,fz    ;no carry in
00403B  1               fROLc_: .byte   fnc,fc,fn,0     ;carry in
00403B  1               fLSR_:
00403B  1               fROR_:  .byte   fc,0,fc,fz      ;no carry in
00403B  1               fRORc_: .byte   fnc,fn,fnc,fn   ;carry in
00403B  1               ;increments (decrements)
00403B  1               rINC_:  .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
00403B  1               fINC_:  .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
00403B  1               ;logical memory operand
00403B  1               absOR_: .byte   0,$1f,$71,$80   ;test pattern for OR
00403B  1               absAN_: .byte   $0f,$ff,$7f,$80 ;test pattern for AND
00403B  1               absEO_: .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
00403B  1               ;logical accu operand
00403B  1               absORa_:.byte   0,$f1,$1f,0     ;test pattern for OR
00403B  1               absANa_:.byte   $f0,$ff,$ff,$ff ;test pattern for AND
00403B  1               absEOa_:.byte   $ff,$f0,$f0,$0f ;test pattern for EOR
00403B  1               ;logical results
00403B  1               absrlo_:.byte   0,$ff,$7f,$80
00403B  1               absflo_:.byte   fz,fn,0,fn
00403B  1               data_end
00403B  1                   .if (data_end - data_init) <> (data_bss_end - data_bss)
00403B  1                       ;force assembler error if size is different
00403B  1                       .error "mismatch between bss and data"
00403B  1                   .endif
00403B  1               
00403B  1               vec_init
00403B  1                       .word   nmi_trap
00403B  1                       .word   res_trap
00403B  1                       .word   irq_trap
00403B  1               vec_bss equ $fffa
00403B  1                   .endif                   ;end of RAM init data
00403B  1               
00403B  1                   .if (load_data_direct = 1) & (ROM_vectors = 1)
00403B  1                       .segment "VECTORS"
00403B  1                       .org $fffa       ;vectors
00FFFA  1  A3 3F                .word   nmi_trap
00FFFC  1  A9 3F                .word   res_trap
00FFFE  1  B1 3F                .word   irq_trap
010000  1                   .endif
010000  1               
